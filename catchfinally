#!/usr/bin/env coffee

test = () ->
  try 
    console.log 'try'
    throw 'abc'
  catch e
    console.log 'catch'
    return e
  finally 
    console.log 'finally'

x = test()
console.log 'test() =>', x

try 
  try
    stuff... ## run (1)
  catch e
    throw ## run as well (2)
  finally
    clean up ## run as well (3)
  stuff2... # skip
catch e
  handle # run (4)
finally
  clean up # run (5)

[tryOnError onError_1]
  [tryOnError onError_2] # this one is very easy to localize - because we register it.
    stuff... [goto onError_2] # any error here - go to the closest error handler 
    # we can make it so there is always an on error label to simplify jumping logic
  [onError_2] # this can have an empty error handler, which will automatically go into finally if it exists...
    # we can register the label here as well... (pop the previous label though so we don't go back again).
    [throw] [goto finally_2] # any error here - go to the closest finally or 
  [finally_2]
    clean up # if there is still an error label here - we will go there.
    [goto onError_1] # inside finally - we can only go to on error one if it hasn't been handled...
    # we also cannot go there for sure either... i.e. unless there is an error, we do not punt further again.
    # i.e. ifOnErrorGoTo should be in play here at the end somewhere.
  more stuff... # these should not be executed i.e. end finally (or end try must exist to send things further out)
[onError_1]
  [try onError_3]
     stuff [goto onError_3]
  [onError_3]
    [throw] [goto finally_3]
  [finally_3]
    clean up 
    [goto finally_1]
    
  
  handle [ifErrorGoto finally_1]
[finally_1]
  [try onError_4]
  [onError_4]
    [throw] [goto finally_4]
  [finally_4]
    [ifError popFrame()] # not wait until the end...
  clean up [ifError popFrame()] # these would occur anyways at the end.

# try always go into the current error handler label (even if there isn't one).
# catch will always go first to finally (if error is thrown inside), then let finally decide how to escape.
# finally will either unwind or go to a parent error handler (only if we are not pass it yet).
# so the key is to handle the error handling correctly inside finally...
# if there is a through inside finally - we will need to know and immediately unwind (unless it's inside an further inner try/catch block).
# that means we need to know where we are when we write throw... 



# if I have a stack... of handlers?


  