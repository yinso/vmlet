// Generated by CoffeeScript 1.4.0
(function() {
  var ANF, AST, CompileTimeEnvironment, Environment, Promise, Runtime, baseEnv, compiler, errorlet, loglet, parser, vm,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  vm = require('vm');

  loglet = require('loglet');

  errorlet = require('errorlet');

  Environment = require('./environment');

  parser = require('./parser');

  AST = require('./ast');

  ANF = require('./anf');

  compiler = require('./anfcompiler');

  baseEnv = require('./baseenv');

  Promise = require('bluebird');

  CompileTimeEnvironment = (function(_super) {

    __extends(CompileTimeEnvironment, _super);

    function CompileTimeEnvironment(inner) {
      this.inner = inner;
    }

    CompileTimeEnvironment.prototype.has = function(key) {
      return this.inner.has(key);
    };

    CompileTimeEnvironment.prototype.get = function(key) {
      return AST.make('proxyval', key, this.inner.get(key));
    };

    return CompileTimeEnvironment;

  })(Environment);

  Runtime = (function() {

    function Runtime(baseEnv) {
      this.baseEnv = baseEnv != null ? baseEnv : baseEnv;
      loglet.log('Runtime.ctor');
      this.parser = parser;
      this.compiler = compiler;
      this.baseEnv.define('console', console);
      this.context = vm.createContext({
        _rt: this,
        console: console,
        process: process
      });
      this.compileEnv = new CompileTimeEnvironment(this.baseEnv);
    }

    Runtime.prototype.define = function(key, val) {
      return this.baseEnv.define(key, val);
    };

    Runtime.prototype["eval"] = function(stmt, cb) {
      var anf, ast, compiled, context;
      if (stmt === ':context') {
        return cb(null, this.context);
      } else if (stmt === ':env') {
        return cb(null, this.baseEnv);
      }
      try {
        loglet.log('-------- Runtime.eval =>', stmt);
        ast = this.parser.parse(stmt);
        loglet.log('-------- Runtime.AST =>', ast);
        anf = ANF.transform(ast, this.compileEnv);
        loglet.log('-------- Runtime.ANF =>', anf);
        compiled = this.compiler.compile(anf);
        loglet.log('-------- Runtime.compile =>', compiled);
        context = vm.createContext({
          _done: cb,
          _rt: this
        });
        return vm.runInContext(compiled, context);
        /*
              switch ast.type()
                when 'define' # our goal is to create the things inside and make a definition.
                  @evalDefine ast.name, ast.val, cb
                when 'funcall'
                  @evalFuncall ast, cb
                else
                  @evalRun ast, cb
        */

      } catch (e) {
        return cb(e);
      }
    };

    Runtime.prototype.get = function(key) {
      return this.baseEnv.get(key);
    };

    Runtime.prototype.bind = function(obj, func) {
      return function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return obj[func].apply(obj, args);
      };
    };

    Runtime.prototype.tail = function() {
      var args, cb, func, isLastArgFunc, lastArg, p, _ref;
      func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (func instanceof Promise) {
        return func;
      }
      lastArg = args[args.length - 1];
      isLastArgFunc = typeof lastArg === 'function' || lastArg instanceof Function;
      cb = isLastArgFunc ? lastArg : function() {};
      if ((_ref = func.__vmlet) != null ? _ref.async : void 0) {
        if (isLastArgFunc) {
          args.pop();
        }
        p = new Promise(function(ok, fail) {
          return func.apply(null, __slice.call(args).concat([function(err, res) {
            if (err) {
              return fail(err);
            } else {
              return ok(res);
            }
          }]));
        });
        p.next = cb;
        return p;
      } else {
        return {
          tail: func,
          args: args,
          cb: cb
        };
      }
    };

    Runtime.prototype.result = function(v) {
      return {
        __vmlet_result: v
      };
    };

    Runtime.prototype.isResult = function(v) {
      return (v != null ? v.__vmlet_result : void 0) || (v !== void 0 && v !== null);
    };

    Runtime.prototype.unbind = function(v) {
      if (v != null ? v.__vmlet_result : void 0) {
        return v.__vmlet_result;
      } else {
        return v;
      }
    };

    Runtime.prototype.tco = function() {
      var args, cb, func, _i;
      func = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
      if (!(typeof func === 'function' || func instanceof Function)) {
        return cb(null, func);
      } else {
        return this._tco(func, args, cb);
      }
    };

    Runtime.prototype["while"] = function(cond, ifTrue, ifFalse) {
      var self;
      self = this;
      return self.tail(cond, function(err, res) {
        if (err) {
          return self.tail(ifFalse, err);
        } else if (!res) {
          return self.tail(isFalse, null, cb);
        } else {
          return self["while"](cond, ifTrue, ifFalse, cb);
        }
      });
    };

    Runtime.prototype._tco = function(func, args, cb) {
      var res, tail;
      args.push(cb);
      tail = {
        tail: func,
        args: args,
        cb: cb
      };
      while (cb !== tail.tail) {
        try {
          res = tail.tail.apply(tail, tail.args);
          if (res instanceof Promise) {
            return this._tcoAsync(res, cb);
          } else if ((res != null ? res.tail : void 0) && (res != null ? res.cb : void 0)) {
            tail = res;
          } else if (this.isResult(res)) {
            return cb(null, this.unbind(res));
          } else {
            return cb(errorlet.create({
              error: 'invalid_tco_function_return',
              value: res
            }));
          }
        } catch (e) {
          return cb(e);
        }
      }
      return tail.tail.apply(tail, tail.args);
    };

    Runtime.prototype._tcoAsync = function(promise, cb) {
      var self;
      self = this;
      return promise.then(function(res) {
        return self._tco(promise.next, [null, res], cb);
      })["catch"](function(err) {
        return self._tco(promise.next, [err, null], cb);
      });
    };

    return Runtime;

  })();

  module.exports = Runtime;

}).call(this);
