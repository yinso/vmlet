// Generated by CoffeeScript 1.4.0
(function() {
  var AST, CPS, Module, RESOLVER, Runtime, Session, SymbolTable, TR, Toplevel, Unit, async, compiler, errorlet, fs, loglet, parser, util, vm,
    __slice = [].slice;

  vm = require('vm');

  loglet = require('loglet');

  errorlet = require('errorlet');

  parser = require('./parser');

  AST = require('./ast');

  RESOLVER = require('./resolver');

  require('./ret');

  CPS = require('./cps');

  SymbolTable = require('./symboltable');

  Unit = require('./unit');

  util = require('./util');

  TR = require('./trace');

  async = require('async');

  compiler = require('./escompile');

  fs = require('fs');

  Session = (function() {

    function Session(cb) {
      this.cb = cb;
    }

    Session.prototype.result = function(v) {
      return {
        __vmlet_result: v
      };
    };

    Session.prototype.isResult = function(v) {
      return (v != null ? v.__vmlet_result : void 0) || (v !== void 0 && v !== null);
    };

    Session.prototype.unbind = function(v) {
      if (v != null ? v.__vmlet_result : void 0) {
        return v.__vmlet_result;
      } else {
        return v;
      }
    };

    Session.prototype.tco = function() {
      var args, func, funcall, res;
      func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      funcall = this.tail.apply(this, [func].concat(__slice.call(args)));
      while (funcall.func !== this.cb) {
        res = funcall.func.apply(funcall, funcall.args);
        if (this.isResult(res)) {
          this.cb(null, this.unbind(res));
        } else if (res.func && res.args && res.cb) {
          return this.tcoAsync.apply(this, [res.fun].concat(__slice.call(res.args), [res.cb]));
        } else if (res.func && res.args) {
          funcall = res;
        }
      }
      return this.cb.apply(this, [null].concat(__slice.call(funcall.args)));
    };

    Session.prototype.tcoAsync = function() {
      var args, cb, func, _i;
      func = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
    };

    Session.prototype.tail = function() {
      var args, func;
      func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return {
        func: func,
        args: args
      };
    };

    Session.prototype.async = function() {
      var args, cb, func, _i;
      func = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
      return {
        func: func,
        args: args,
        cb: cb
      };
    };

    return Session;

  })();

  Module = (function() {

    Module.fromPrev = function(name, prevEnv) {
      return new this(name, new SymbolTable(prevEnv));
    };

    function Module(name, env) {
      this.name = name;
      this.env = env != null ? env : new SymbolTable();
      this.inner = {};
      this.imports = {};
      this.exports = {};
      this.depends = [];
    }

    Module.prototype.idName = function() {
      if (this.name === ':main') {
        return AST.moduleID;
      } else {
        return AST.symbol(this.name.replace(/[\.\\\/]/g, '_'));
      }
    };

    Module.prototype.define = function(key, val) {
      this.inner[key] = val;
      return val;
    };

    Module.prototype["export"] = function(obj) {
      var key, val, _results;
      _results = [];
      for (key in obj) {
        val = obj[key];
        if (obj.hasOwnProperty(key)) {
          _results.push(this.exports[key] = val);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Module.prototype["import"] = function(keys) {
      var key, res, _i, _len;
      if (keys == null) {
        keys = [];
      }
      if (keys.length > 0) {
        res = [];
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          res[key] = this.get(key);
        }
        return res;
      } else {
        return this.exports;
      }
    };

    Module.prototype.has = function(key) {
      return this.inner.hasOwnProperty(key);
    };

    Module.prototype.get = function(key) {
      if (!this.has(key)) {
        throw new Error("Module.unknown_identifier: " + key);
      }
      return this.inner[key];
    };

    return Module;

  })();

  Toplevel = (function() {

    function Toplevel(depends, proc, module) {
      this.depends = depends;
      this.proc = proc;
      this.module = module;
    }

    Toplevel.prototype["eval"] = function(cb) {
      var args;
      args = [this.module].concat(this.depends).concat([cb]);
      try {
        return this.proc.apply(this, args);
      } catch (e) {
        return cb(e);
      }
    };

    return Toplevel;

  })();

  Runtime = (function() {

    function Runtime(baseEnv, main) {
      this.baseEnv = baseEnv != null ? baseEnv : new SymbolTable();
      this.main = main != null ? main : Module.fromPrev(':main', this.baseEnv);
      this.modules = {};
      this.envs = {};
      this.parser = parser;
      this.AST = AST;
      this.baseEnv.define(AST.symbol('fs'), AST.proxyval('fs', AST.symbol('fs')));
      this.baseEnv.define(AST.symbol('console'), AST.proxyval('console', AST.symbol('console')));
      this.baseEnv.define(AST.symbol('import'), AST.proxyval('import', AST.member(AST.runtimeID, AST.symbol('import'))));
      this.context = vm.createContext({
        _rt: this,
        console: console,
        process: process,
        fs: fs
      });
    }

    Runtime.prototype.unit = Unit.unit;

    Runtime.prototype.proc = function(func, def) {
      Object.defineProperty(func, '__vmlet', {
        value: {
          sync: true,
          def: def
        }
      });
      return func;
    };

    Runtime.prototype.task = function(func, def) {
      Object.defineProperty(func, '__vmlet', {
        value: {
          sync: false,
          def: def
        }
      });
      return func;
    };

    Runtime.prototype.member = function(head, key) {
      var res;
      res = head[key];
      if (util.isFunction(res)) {
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return res.apply(head, args);
        };
      } else {
        return res;
      }
    };

    Runtime.prototype.toplevel = function(depends, proc, module) {
      var dep, modules;
      if (module == null) {
        module = this.main;
      }
      modules = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = depends.length; _i < _len; _i++) {
          dep = depends[_i];
          if (!this.modules.hasOwnProperty(dep)) {
            throw new Error("runtime:unknown_module: " + spec);
          }
          _results.push(this.modules[dep]);
        }
        return _results;
      }).call(this);
      return new Toplevel(modules, proc, module);
    };

    Runtime.prototype.module = function(id, depends, proc) {
      if (!this.envs.hasOwnProperty(id)) {
        throw new Error("runtime:invalid_module_env: " + spec);
      }
      return this.toplevel(depends, proc, new Module(id, this.envs[id]));
    };

    Runtime.prototype.makeSync = function(funcMaker) {
      var func;
      func = funcMaker(this);
      func.__vmlet = {
        sync: true
      };
      return func;
    };

    Runtime.prototype.makeAsync = function(funcMaker) {
      var func;
      func = funcMaker(this);
      func.__vmlet = {
        async: true
      };
      return func;
    };

    Runtime.prototype.defineSync = function(key, funcMaker) {
      return this.define(key, this.makeSync(funcMaker));
    };

    Runtime.prototype.defineAsync = function(key, funcMaker) {
      return this.define(key, this.makeAsync(funcMaker));
    };

    Runtime.prototype.parse = function(stmt) {
      var ast;
      ast = this.parser.parse(stmt);
      return ast;
    };

    Runtime.prototype.transform = function(ast, env) {
      if (env == null) {
        env = this.main.env;
      }
      ast = RESOLVER.transform(ast, env);
      return ast;
    };

    Runtime.prototype.compile = function(ast) {
      var compiled;
      compiled = compiler.compile(ast);
      console.log('--Runtime.compile', compiled);
      return vm.runInContext(compiled, this.context);
    };

    Runtime.prototype.isPackage = function(filePath) {
      return false;
    };

    Runtime.prototype["eval"] = function(stmt, cb) {
      var ast;
      if (stmt.indexOf(':modules') === 0) {
        return cb(null, util.prettify(this.modules));
      } else if (stmt.indexOf(':env') === 0) {
        return cb(null, util.prettify(this.main));
      }
      try {
        ast = AST.toplevel(this.parse(stmt));
        return this.evalParsed(ast, this.main.env, cb);
      } catch (e) {
        return cb(e);
      }
    };

    Runtime.prototype.evalParsed = function(ast, env, cb) {
      var _this = this;
      return this.loadImports(ast, function(err) {
        var compiled;
        if (err) {
          return cb(err);
        } else {
          try {
            ast = _this.transform(ast, env);
            compiled = _this.compile(ast);
            return compiled["eval"](function(err, res) {
              if (err) {
                return cb(err);
              } else if (res instanceof Unit) {
                return cb(null);
              } else {
                return cb(err, res);
              }
            });
          } catch (e) {
            return cb(e);
          }
        }
      });
    };

    Runtime.prototype.loadImports = function(ast, cb) {
      var _this = this;
      try {
        return async.eachSeries(ast.importSpecs(), function(spec, next) {
          return _this.loadImport(spec, next);
        }, cb);
      } catch (e) {
        return cb(e);
      }
    };

    Runtime.prototype.loadImport = function(spec, cb) {
      var _this = this;
      try {
        return fs.readFile(spec, 'utf8', function(err, data) {
          var parsed;
          if (err) {
            return cb(err);
          } else {
            try {
              parsed = AST.module(AST.string(spec), _this.parse(data));
              _this.envs[spec] = new SymbolTable(_this.baseEnv);
              return _this.evalParsed(parsed, _this.envs[spec], function(err, module) {
                if (err) {
                  return cb(err);
                } else {
                  _this.modules[spec] = module;
                  return cb(null);
                }
              });
            } catch (e) {
              return cb(e);
            }
          }
        });
      } catch (e) {
        return cb(e);
      }
    };

    return Runtime;

  })();

  module.exports = Runtime;

}).call(this);
