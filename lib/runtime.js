// Generated by CoffeeScript 1.4.0
(function() {
  var AST, CPS, Module, Promise, RESOLVER, Runtime, Session, SymbolTable, TR, Toplevel, UNIQ, Unit, async, errorlet, escodegen, esnode, fs, loglet, parser, util, vm,
    __slice = [].slice;

  vm = require('vm');

  loglet = require('loglet');

  errorlet = require('errorlet');

  parser = require('./parser');

  AST = require('./ast');

  RESOLVER = require('./resolver');

  require('./ret');

  CPS = require('./cps');

  SymbolTable = require('./symboltable');

  Unit = require('./unit');

  util = require('./util');

  TR = require('./trace');

  UNIQ = require('./unique');

  async = require('async');

  esnode = require('./esnode');

  escodegen = require('escodegen');

  Promise = require('bluebird');

  fs = require('fs');

  Session = (function() {

    function Session(cb) {
      this.cb = cb;
    }

    Session.prototype.result = function(v) {
      return {
        __vmlet_result: v
      };
    };

    Session.prototype.isResult = function(v) {
      return (v != null ? v.__vmlet_result : void 0) || (v !== void 0 && v !== null);
    };

    Session.prototype.unbind = function(v) {
      if (v != null ? v.__vmlet_result : void 0) {
        return v.__vmlet_result;
      } else {
        return v;
      }
    };

    Session.prototype.tco = function() {
      var args, func, funcall, res;
      func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      funcall = this.tail.apply(this, [func].concat(__slice.call(args)));
      while (funcall.func !== this.cb) {
        res = funcall.func.apply(funcall, funcall.args);
        if (this.isResult(res)) {
          this.cb(null, this.unbind(res));
        } else if (res.func && res.args && res.cb) {
          return this.tcoAsync.apply(this, [res.fun].concat(__slice.call(res.args), [res.cb]));
        } else if (res.func && res.args) {
          funcall = res;
        }
      }
      return this.cb.apply(this, [null].concat(__slice.call(funcall.args)));
    };

    Session.prototype.tcoAsync = function() {
      var args, cb, func, _i;
      func = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
    };

    Session.prototype.tail = function() {
      var args, func;
      func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return {
        func: func,
        args: args
      };
    };

    Session.prototype.async = function() {
      var args, cb, func, _i;
      func = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
      return {
        func: func,
        args: args,
        cb: cb
      };
    };

    return Session;

  })();

  Module = (function() {

    function Module(prevEnv) {
      this.prevEnv = prevEnv != null ? prevEnv : null;
      this.inner = {};
      this.imports = {};
      this.exports = {};
      this.depends = [];
      this.env = new SymbolTable(this.prevEnv);
    }

    Module.prototype.define = function(key, val) {
      this.inner[key] = val;
      return val;
    };

    Module.prototype["export"] = function(key, as) {
      if (as == null) {
        as = key;
      }
    };

    Module.prototype["import"] = function(keys) {
      var key, res, _i, _len;
      if (keys == null) {
        keys = [];
      }
      if (keys.length > 0) {
        res = [];
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          res[key] = this.get(key);
        }
        return res;
      } else {
        return this.exports;
      }
    };

    Module.prototype.has = function(key) {
      return this.inner.hasOwnProperty(key);
    };

    Module.prototype.get = function(key) {
      if (!this.has(key)) {
        throw new Error("Module.unknown_identifier: " + key);
      }
      return this.inner[key];
    };

    return Module;

  })();

  Toplevel = (function() {

    function Toplevel(depends, proc, module) {
      this.depends = depends;
      this.proc = proc;
      this.module = module;
    }

    Toplevel.prototype["eval"] = function(cb) {
      try {
        return this.proc(this.module, cb);
      } catch (e) {
        return cb(e);
      }
    };

    return Toplevel;

  })();

  Runtime = (function() {

    function Runtime(baseEnv, main) {
      this.baseEnv = baseEnv != null ? baseEnv : new SymbolTable();
      this.main = main != null ? main : new Module(this.baseEnv);
      this.modules = {};
      this.parser = parser;
      this.AST = AST;
      this.baseEnv.define(AST.symbol('fs'), {
        readFile: this.makeAsync(function(_rt) {
          var readFile;
          readFile = _rt.member(fs, 'readFile');
          return function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return readFile.apply(null, args);
          };
        })
      });
      this.baseEnv.define(AST.symbol('console'), AST.proxyval('console', AST.symbol('console')));
      this.baseEnv.define(AST.symbol('import'), AST.proxyval('import', AST.member(AST.symbol('_rt'), AST.symbol('import'))));
      this.context = vm.createContext({
        _rt: this,
        console: console,
        process: process
      });
    }

    Runtime.prototype.unit = Unit.unit;

    Runtime.prototype.proc = function(func, def) {
      Object.defineProperty(func, '__vmlet', {
        value: {
          sync: true,
          def: def
        }
      });
      return func;
    };

    Runtime.prototype.task = function(func, def) {
      Object.defineProperty(func, '__vmlet', {
        value: {
          sync: false,
          def: def
        }
      });
      return func;
    };

    Runtime.prototype.member = function(head, key) {
      var res;
      res = head[key];
      if (util.isFunction(res)) {
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return res.apply(head, args);
        };
      } else {
        return res;
      }
    };

    Runtime.prototype.toplevel = function(depends, proc, module) {
      if (module == null) {
        module = this.main;
      }
      return new Toplevel(depends, proc, this.main);
    };

    Runtime.prototype.module = function(depends, proc) {
      return this.toplevel(depends, proc, new Module(this.baseEnv));
    };

    Runtime.prototype.makeSync = function(funcMaker) {
      var func;
      func = funcMaker(this);
      func.__vmlet = {
        sync: true
      };
      return func;
    };

    Runtime.prototype.makeAsync = function(funcMaker) {
      var func;
      func = funcMaker(this);
      func.__vmlet = {
        async: true
      };
      return func;
    };

    Runtime.prototype.defineSync = function(key, funcMaker) {
      return this.define(key, this.makeSync(funcMaker));
    };

    Runtime.prototype.defineAsync = function(key, funcMaker) {
      return this.define(key, this.makeAsync(funcMaker));
    };

    Runtime.prototype.compile = function(ast) {
      var compiled, node;
      node = ast.toESNode();
      compiled = '(' + escodegen.generate(node) + ')';
      loglet.log('-------- Runtime.compiled =>', compiled);
      return vm.runInContext(compiled, this.context);
    };

    Runtime.prototype.parse = function(stmt) {
      var ast;
      ast = this.parser.parse(stmt);
      loglet.log('-------- Runtime.parsed =>', ast);
      return ast;
    };

    Runtime.prototype.isPackage = function(filePath) {
      return false;
    };

    Runtime.prototype["eval"] = function(stmt, cb) {
      var ast;
      if (stmt === ':context') {
        return cb(null, this.context);
      } else if (stmt === ':env') {
        return cb(null, this.baseEnv);
      }
      try {
        ast = AST.toplevel(this.parse(stmt));
        return this.evalParsed(ast, cb);
      } catch (e) {
        return cb(e);
      }
    };

    Runtime.prototype.evalParsed = function(ast, cb) {
      var _this = this;
      return this.loadImports(ast, function(err) {
        var compiled;
        console.log('--evalParsed.after.import', ast, err);
        if (err) {
          return cb(err);
        } else {
          try {
            ast = _this.transform(ast);
            compiled = _this.compile(ast);
            return compiled["eval"](function(err, res) {
              console.log('--evalParsed.compiled.result', err, res);
              if (err) {
                return cb(err);
              } else if (res instanceof Unit) {
                return cb(null);
              } else {
                return cb(err, res);
              }
            });
          } catch (e) {
            return cb(e);
          }
        }
      });
    };

    Runtime.prototype.loadImports = function(ast, cb) {
      var _this = this;
      try {
        return async.eachSeries(ast.importSpecs(), function(spec, next) {
          return _this.loadImport(spec, next);
        }, cb);
      } catch (e) {
        return cb(e);
      }
    };

    Runtime.prototype.loadImport = function(spec, cb) {
      var _this = this;
      console.log('-- runtime.loadImport', spec);
      try {
        return fs.readFile(spec, 'utf8', function(err, data) {
          var parsed;
          console.log('-- runtime.loadImport.loaded', err, data);
          if (err) {
            return cb(err);
          } else {
            try {
              parsed = AST.module(_this.parse(data));
              console.log('-- runtime.loadImport.parsed', parsed);
              return _this.evalParsed(parsed, function(err, module) {
                console.log('-- runtime.loadImport.result', err, module);
                if (err) {
                  return cb(err);
                } else {
                  _this.modules[spec] = module;
                  return cb(null);
                }
              });
            } catch (e) {
              return cb(e);
            }
          }
        });
      } catch (e) {
        return cb(e);
      }
    };

    Runtime.prototype.transform = function(ast, module) {
      if (module == null) {
        module = this.main;
      }
      ast = RESOLVER.transform(ast, module.env);
      loglet.log('-------- Runtime.transformed =>', ast, module.env);
      return ast;
    };

    Runtime.prototype.get = function(key) {
      return this.baseEnv.get(key);
    };

    Runtime.prototype.promise = function() {
      var args, cb, func, p, _i;
      func = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
      loglet.log('_rt.promise', func, args, cb);
      p = new Promise(function(ok, fail) {
        return func.apply(null, __slice.call(args).concat([function(err, res) {
          loglet.log('_rt.promise.call', err, res);
          if (err) {
            return fail(err);
          } else {
            return ok(res);
          }
        }]));
      });
      p.next = cb;
      return p;
    };

    Runtime.prototype.tailAsync = function() {
      var args, cb, func, _i;
      func = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
      return {
        tail: func,
        args: args,
        cb: cb
      };
    };

    Runtime.prototype.tail = function() {
      var args, func;
      func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return {
        tail: func,
        args: args
      };
    };

    Runtime.prototype.result = function(v) {
      return {
        __vmlet_result: v
      };
    };

    Runtime.prototype.isResult = function(v) {
      return (v != null ? v.__vmlet_result : void 0) || (v !== void 0 && v !== null);
    };

    Runtime.prototype.unbind = function(v) {
      if (v != null ? v.__vmlet_result : void 0) {
        return v.__vmlet_result;
      } else {
        return v;
      }
    };

    Runtime.prototype.tco = function() {
      var args, cb, func, _i;
      func = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
      if (!util.isFunction(func)) {
        if (func instanceof Unit) {
          return cb(null);
        } else {
          return cb(null, func);
        }
      } else {
        return this._tco(func, args, cb);
      }
    };

    Runtime.prototype["while"] = function(cond, ifTrue, ifFalse) {
      var self;
      self = this;
      return self.tail(cond, function(err, res) {
        if (err) {
          return self.tail(ifFalse, err);
        } else if (!res) {
          return self.tail(isFalse, null, cb);
        } else {
          return self["while"](cond, ifTrue, ifFalse, cb);
        }
      });
    };

    Runtime.prototype._tco = function(func, args, cb) {
      var funcall, res, _ref;
      if ((_ref = func.__vmlet) != null ? _ref.async : void 0) {
        args.push(cb);
      }
      funcall = {
        tail: func,
        args: args,
        cb: cb
      };
      while (cb !== funcall.tail) {
        try {
          res = funcall.tail.apply(funcall, funcall.args);
          if ((res != null ? res.tail : void 0) && (res != null ? res.cb : void 0)) {
            return this._tcoAsync(res, cb);
          } else if (res != null ? res.tail : void 0) {
            funcall = res;
          } else if (this.isResult(res)) {
            if (res instanceof Unit) {
              return cb(null);
            }
            return cb(null, this.unbind(res));
          } else {
            return cb(errorlet.create({
              error: 'invalid_tco_function_return',
              value: res
            }));
          }
        } catch (e) {
          return cb(e);
        }
      }
      return tail.tail.apply(tail, tail.args);
    };

    Runtime.prototype.tcoAsync = function() {
      var args, cb, func, self, _i;
      func = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
      self = this;
      return funcall.tail.apply(funcall, __slice.call(funcall.args).concat([function(err, res) {
        if (err) {
          return cb(err);
        } else {

        }
      }]));
    };

    Runtime.prototype._tcoAsync = function(funcall, cb) {
      var self;
      self = this;
      return funcall.tail.apply(funcall, __slice.call(funcall.args).concat([function(err, res) {}]));
    };

    return Runtime;

  })();

  module.exports = Runtime;

}).call(this);
