// Generated by CoffeeScript 1.4.0
(function() {
  var ANF, AST, CPS, Environment, LOCAL, LexicalEnvironment, Promise, RESOLVER, RET, Runtime, Session, Unit, baseEnv, errorlet, escodegen, esnode, fs, loglet, parser, util, vm,
    __slice = [].slice;

  vm = require('vm');

  loglet = require('loglet');

  errorlet = require('errorlet');

  Environment = require('./environment');

  parser = require('./parser');

  AST = require('./ast');

  RESOLVER = require('./resolver');

  ANF = require('./anf');

  LOCAL = require('./local');

  RET = require('./return');

  CPS = require('./cps');

  baseEnv = require('./baseenv');

  Unit = require('./unit');

  util = require('./util');

  LexicalEnvironment = require('./lexical');

  esnode = require('./esnode');

  escodegen = require('escodegen');

  Promise = require('bluebird');

  fs = require('fs');

  /*
  class CompileTimeEnvironment extends Environment
    constructor: (@inner) ->
    has: (key) ->
      @inner.has key
    get: (key) ->
      # we want it to return something that would be of substitute?
      # this doesn't work - we need something that says it's available as a SUPER_REF. i.e. not a LOCAL_REF
      # that are 
      AST.make('proxyval', key, 
        @inner.get(key), 
        (ast) ->
          "_rt.get(#{JSON.stringify(ast.name)})"
      )
  */


  Session = (function() {

    function Session(cb) {
      this.cb = cb;
    }

    Session.prototype.result = function(v) {
      return {
        __vmlet_result: v
      };
    };

    Session.prototype.isResult = function(v) {
      return (v != null ? v.__vmlet_result : void 0) || (v !== void 0 && v !== null);
    };

    Session.prototype.unbind = function(v) {
      if (v != null ? v.__vmlet_result : void 0) {
        return v.__vmlet_result;
      } else {
        return v;
      }
    };

    Session.prototype.tco = function() {
      var args, func, funcall, res;
      func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      funcall = this.tail.apply(this, [func].concat(__slice.call(args)));
      while (funcall.func !== this.cb) {
        res = funcall.func.apply(funcall, funcall.args);
        if (this.isResult(res)) {
          this.cb(null, this.unbind(res));
        } else if (res.func && res.args && res.cb) {
          return this.tcoAsync.apply(this, [res.fun].concat(__slice.call(res.args), [res.cb]));
        } else if (res.func && res.args) {
          funcall = res;
        }
      }
      return this.cb.apply(this, [null].concat(__slice.call(funcall.args)));
    };

    Session.prototype.tcoAsync = function() {
      var args, cb, func, _i;
      func = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
    };

    Session.prototype.tail = function() {
      var args, func;
      func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return {
        func: func,
        args: args
      };
    };

    Session.prototype.async = function() {
      var args, cb, func, _i;
      func = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
      return {
        func: func,
        args: args,
        cb: cb
      };
    };

    return Session;

  })();

  Runtime = (function() {

    function Runtime(baseEnv) {
      this.baseEnv = baseEnv != null ? baseEnv : baseEnv;
      loglet.log('Runtime.ctor');
      this.parser = parser;
      this.define('console', {
        log: this.makeSync(function(_rt) {
          return function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            console.log.apply(console, args);
            return Unit.unit;
          };
        }),
        time: this.makeSync(function(_rt) {
          return function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            console.time.apply(console, args);
            return Unit.unit;
          };
        }),
        timeEnd: this.makeSync(function(_rt) {
          return function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            console.timeEnd.apply(console, args);
            return Unit.unit;
          };
        }),
        debug: this.makeSync(function(_rt) {
          return function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            console.debug.apply(console, args);
            return Unit.unit;
          };
        }),
        error: this.makeSync(function(_rt) {
          return function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            console.error.apply(console, args);
            return Unit.unit;
          };
        })
      });
      this.define('fs', {
        readFile: this.makeAsync(function(_rt) {
          var readFile;
          readFile = _rt.member(fs, 'readFile');
          return function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return readFile.apply(null, args);
          };
        })
      });
      this.context = vm.createContext({
        _rt: this,
        console: console,
        process: process
      });
    }

    Runtime.prototype.unit = Unit.unit;

    Runtime.prototype.define = function(key, val) {
      return baseEnv.define(key, val);
    };

    Runtime.prototype.makeSync = function(funcMaker) {
      var func;
      func = funcMaker(this);
      func.__vmlet = {
        sync: true
      };
      return func;
    };

    Runtime.prototype.makeAsync = function(funcMaker) {
      var func;
      func = funcMaker(this);
      func.__vmlet = {
        async: true
      };
      return func;
    };

    Runtime.prototype.defineSync = function(key, funcMaker) {
      return this.define(key, this.makeSync(funcMaker));
    };

    Runtime.prototype.defineAsync = function(key, funcMaker) {
      return this.define(key, this.makeAsync(funcMaker));
    };

    Runtime.prototype.compile = function(ast) {
      var node;
      node = esnode.expression(AST.funcall(AST.procedure(null, [], AST.block([AST["return"](ast)])), []).toESNode());
      return escodegen.generate(node);
    };

    Runtime.prototype["eval"] = function(stmt, cb) {
      var ast, compiled, compiler,
        _this = this;
      if (stmt === ':context') {
        return cb(null, this.context);
      } else if (stmt === ':env') {
        return cb(null, this.baseEnv);
      }
      try {
        loglet.log('-------- Runtime.eval =>', stmt);
        ast = this.parser.parse(stmt);
        loglet.log('-------- Runtime.parsed =>', ast);
        ast = RESOLVER.transform(ast, new LexicalEnvironment());
        loglet.log('-------- Runtime.transformed =>', ast);
        ast = CPS.transform(ast);
        loglet.log('-------- Runtime.cpsed =>', ast.type());
        compiled = this.compile(ast);
        loglet.log('-------- Runtime.compiled =>', compiled);
        compiler = vm.runInContext(compiled, this.context);
        loglet.log('-------- Runtime.evaled =>', compiler);
        try {
          return compiler(this, function(err, res) {
            if (err) {
              return cb(err);
            } else if (res instanceof Unit) {
              return cb(null);
            } else if (_this.isResult(res)) {
              return cb(null, _this.unbind(res));
            } else {
              return cb(err, res);
            }
          });
        } catch (e) {
          return cb(e);
        }
      } catch (e) {
        return cb(e);
      }
    };

    Runtime.prototype.get = function(key) {
      return this.baseEnv.get(key);
    };

    Runtime.prototype.member = function(obj, key) {
      var member;
      member = obj[key];
      if (util.isFunction(member)) {
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return obj[key].apply(obj, args);
        };
      } else {
        return member;
      }
    };

    Runtime.prototype.promise = function() {
      var args, cb, func, p, _i;
      func = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
      loglet.log('_rt.promise', func, args, cb);
      p = new Promise(function(ok, fail) {
        return func.apply(null, __slice.call(args).concat([function(err, res) {
          loglet.log('_rt.promise.call', err, res);
          if (err) {
            return fail(err);
          } else {
            return ok(res);
          }
        }]));
      });
      p.next = cb;
      return p;
    };

    Runtime.prototype.tailAsync = function() {
      var args, cb, func, _i;
      func = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
      return {
        tail: func,
        args: args,
        cb: cb
      };
    };

    Runtime.prototype.tail = function() {
      var args, func;
      func = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return {
        tail: func,
        args: args
      };
    };

    Runtime.prototype.result = function(v) {
      return {
        __vmlet_result: v
      };
    };

    Runtime.prototype.isResult = function(v) {
      return (v != null ? v.__vmlet_result : void 0) || (v !== void 0 && v !== null);
    };

    Runtime.prototype.unbind = function(v) {
      if (v != null ? v.__vmlet_result : void 0) {
        return v.__vmlet_result;
      } else {
        return v;
      }
    };

    Runtime.prototype.tco = function() {
      var args, cb, func, _i;
      func = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
      if (!util.isFunction(func)) {
        if (func instanceof Unit) {
          return cb(null);
        } else {
          return cb(null, func);
        }
      } else {
        return this._tco(func, args, cb);
      }
    };

    Runtime.prototype["while"] = function(cond, ifTrue, ifFalse) {
      var self;
      self = this;
      return self.tail(cond, function(err, res) {
        if (err) {
          return self.tail(ifFalse, err);
        } else if (!res) {
          return self.tail(isFalse, null, cb);
        } else {
          return self["while"](cond, ifTrue, ifFalse, cb);
        }
      });
    };

    Runtime.prototype._tco = function(func, args, cb) {
      var funcall, res, _ref;
      if ((_ref = func.__vmlet) != null ? _ref.async : void 0) {
        args.push(cb);
      }
      funcall = {
        tail: func,
        args: args,
        cb: cb
      };
      while (cb !== funcall.tail) {
        try {
          res = funcall.tail.apply(funcall, funcall.args);
          if ((res != null ? res.tail : void 0) && (res != null ? res.cb : void 0)) {
            return this._tcoAsync(res, cb);
          } else if (res != null ? res.tail : void 0) {
            funcall = res;
          } else if (this.isResult(res)) {
            if (res instanceof Unit) {
              return cb(null);
            }
            return cb(null, this.unbind(res));
          } else {
            return cb(errorlet.create({
              error: 'invalid_tco_function_return',
              value: res
            }));
          }
        } catch (e) {
          return cb(e);
        }
      }
      return tail.tail.apply(tail, tail.args);
    };

    Runtime.prototype.tcoAsync = function() {
      var args, cb, func, self, _i;
      func = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), cb = arguments[_i++];
      self = this;
      return funcall.tail.apply(funcall, __slice.call(funcall.args).concat([function(err, res) {
        if (err) {
          return cb(err);
        } else {

        }
      }]));
    };

    Runtime.prototype._tcoAsync = function(funcall, cb) {
      var self;
      self = this;
      return funcall.tail.apply(funcall, __slice.call(funcall.args).concat([function(err, res) {}]));
    };

    return Runtime;

  })();

  module.exports = Runtime;

}).call(this);
