// Generated by CoffeeScript 1.4.0
(function() {
  var AST, CLONE, CPS, T, TCO, atomicTypes, tr,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  AST = require('./ast');

  T = require('./transformer');

  tr = require('./trace');

  CPS = require('./cps');

  TCO = require('./tail');

  CLONE = require('./clone');

  atomicTypes = ['string', 'procedure', 'bool', 'null', 'undefined', 'number', 'procedure', 'task', 'binary', 'funcall'];

  T.register('return', function($r) {
    var _ref;
    return _ref = $r.value.type(), __indexOf.call(atomicTypes, _ref) >= 0;
  }, function($r) {
    return $r;
  });

  T.register('return', function($r) {
    return $r.value.type() === 'block';
  }, function($r) {
    var i, item;
    return AST.block((function() {
      var _i, _len, _ref, _results;
      _ref = $r.value.items;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        item = _ref[i];
        if (i < $r.value.items.length - 1) {
          _results.push(T.transform(item));
        } else {
          _results.push(T.transform(AST["return"](item)));
        }
      }
      return _results;
    })());
  });

  T.register('return', function($r) {
    return $r.value.type() === 'return';
  }, function($r) {
    return $r.value;
  });

  T.register('return', function($r) {
    return $r.value.type() === 'throw';
  }, function($r) {
    return $r.value;
  });

  T.register('return', function($r) {
    if ($r.value.type() === 'local') {
      return [$r.value.value];
    } else {
      return false;
    }
  }, function($r, $inner) {
    return T.transform(AST["return"]($inner));
  });

  T.register('return', function($r) {
    if ($r.value.type() === 'if') {
      return [$r.value.cond, $r.value.then, $r.value["else"]];
    }
  }, function($r, $cond, $then, $else) {
    var elseExp, thenExp;
    thenExp = T.transform(AST["return"]($then));
    elseExp = T.transform(AST["return"]($else));
    return AST["if"]($cond, thenExp, elseExp);
  });

  T.register('return', function($r) {
    if ($r.value.type() === 'try') {
      return [$r.value.body, $r.value.catches, $r.value["finally"]];
    } else {
      return false;
    }
  }, function($r, $body, $catches, $finally) {
    var body, catches, final, handler;
    body = T.transform(AST["return"]($body));
    catches = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = $catches.length; _i < _len; _i++) {
        handler = $catches[_i];
        _results.push(T.transform(AST["return"](handler)));
      }
      return _results;
    })();
    final = $finally ? T.transform($finally) : null;
    return AST["try"](body, catches, final);
  });

  T.register('return', function($r) {
    if ($r.value.type() === 'catch') {
      return [$r.value.param, $r.value.body];
    } else {
      return false;
    }
  }, function($r, $param, $body) {
    return AST["catch"]($param, T.transform(AST["return"]($body)));
  });

  T.register('return', function($r) {
    if ($r.value.type() === 'finally') {
      return $r.value;
    } else {
      return false;
    }
  }, function($r, $finally) {
    return T.transform($finally);
  });

  T.register('return', function($r) {
    if ($r.value.type() === 'let') {
      return [$r.value.defines, $r.value.body];
    }
  }, function($r, $defines, $body) {
    return AST["let"]($defines, T.transform(AST["return"]($body)));
  });

  T.register('return', function($r) {
    if ($r.value.type() === 'while') {
      return [$r.value.cond, $r.value.block];
    }
  }, function($r, $cond, $block) {
    return AST["while"]($cond, T.transform(AST["return"]($block)));
  });

  T.register('return', function($r) {
    if ($r.value.type() === 'switch') {
      return [$r.value.cond, $r.value.cases];
    }
  }, function($r, $cond, $cases) {
    var c;
    return AST["switch"]($cond, (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = $cases.length; _i < _len; _i++) {
        c = $cases[_i];
        _results.push(T.transform(AST["return"](c)));
      }
      return _results;
    })());
  });

  T.register('return', function($r) {
    if ($r.value.type() === 'case') {
      return [$r.value.cond, $r.value.exp];
    }
  }, function($r, $cond, $exp) {
    return AST["case"]($cond, T.transform(AST["return"]($exp)));
  });

  T.register('return', function($r) {
    if ($r.value.type() === 'defaultCase') {
      return [$r.value.exp];
    }
  }, function($r, $exp) {
    return AST.defaultCase(T.transform(AST["return"]($exp)));
  });

  T.register('return', function($r) {
    if ($r.value.type() === 'break') {
      return [$r.value];
    }
  }, function($r, $break) {
    return $break;
  });

  T.register('return', function($r) {
    if ($r.value.type() === 'continue') {
      return [$r.value];
    }
  }, function($r, $continue) {
    return $continue;
  });

  T.register('local', function($l) {
    var val, _ref;
    if (!$l.value) {
      return false;
    }
    val = $l.value;
    return _ref = val.type(), __indexOf.call(atomicTypes, _ref) >= 0;
  }, function($l) {
    return $l;
  });

  T.register('local', function($l) {
    var val;
    if (!$l.value) {
      return false;
    }
    val = $l.value;
    if (val.type() === 'if') {
      return [val.cond, val.then, val["else"]];
    }
  }, function($l, $cond, $then, $else) {
    var elseExp, thenExp;
    thenExp = T.transform($l.assign($then));
    elseExp = T.transform($l.assign($else));
    return AST.block([$l.noInit(), AST["if"]($cond, thenExp, elseExp)]);
  });

  T.register('local', function($l) {
    var val;
    if (!$l.value) {
      return false;
    }
    val = $l.value;
    if (val.type() === 'block') {
      return val.items;
    } else {
      return false;
    }
  }, function() {
    var $items, $l, i, item, items, _i, _len;
    $l = arguments[0], $items = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    items = [$l.noInit()];
    for (i = _i = 0, _len = $items.length; _i < _len; i = ++_i) {
      item = $items[i];
      if (i < $items.length - 1) {
        items.push(T.transform(item));
      } else {
        items.push(T.transform(AST.assign($l.name(), item)));
      }
    }
    return AST.block(items);
  });

  T.register('local', function($l) {
    var val;
    if (!$l.value) {
      return false;
    }
    val = $l.value;
    if (val.type() === 'try') {
      return [val.body, val.catches, val["finally"]];
    } else {
      return false;
    }
  }, function($l, $body, $catches, $finally) {
    var body, catches, final, handler;
    body = T.transform(AST.assign($l.name, $body));
    catches = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = $catches.length; _i < _len; _i++) {
        handler = $catches[_i];
        _results.push(T.transform(AST.assign($l.name, handler)));
      }
      return _results;
    })();
    final = T.transform($finally);
    return AST.block([$l.noInit(), AST["try"](body, catches, final)]);
  });

  T.register('assign', function($a) {
    var _ref;
    return _ref = $a.value.type(), __indexOf.call(atomicTypes, _ref) >= 0;
  }, function($a) {
    return $a;
  });

  T.register('assign', function($a) {
    if ($a.value.type() === 'block') {
      return $a.value.items;
    } else {
      return false;
    }
  }, function() {
    var $a, $items, i, item, items;
    $a = arguments[0], $items = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    items = (function() {
      var _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = $items.length; _i < _len; i = ++_i) {
        item = $items[i];
        if (i < $items.length - 1) {
          _results.push(T.transform(item));
        } else {
          _results.push(T.transform(AST.assign($a.name, item)));
        }
      }
      return _results;
    })();
    return AST.block(items);
  });

  T.register('assign', function($a) {
    if ($a.value.type() === 'if') {
      return [$a.value.cond, $a.value.then, $a.value["else"]];
    } else {
      return false;
    }
  }, function($a, $cond, $then, $else) {
    return AST["if"]($cond, T.transform(AST.assign($a.name, $cond)), T.transform(AST.assign($a.name, $else)));
  });

  T.register('assign', function($a) {
    if ($a.value.type() === 'try') {
      return [$a.value.body, $a.value.catches, $a.value["finally"]];
    } else {
      return false;
    }
  }, function($a, $body, $catches, $finally) {
    var body, catches, final, handler;
    body = T.transform(AST.assign($a.name, $body));
    catches = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = $catches.length; _i < _len; _i++) {
        handler = $catches[_i];
        _results.push(T.transform(AST.assign($a.name, handler)));
      }
      return _results;
    })();
    final = T.transform($finally);
    return AST["try"](body, catches, final);
  });

  T.register('assign', function($a) {
    if ($a.value.type() === 'catch') {
      return [$a.value.param, $a.value.body];
    } else {
      return false;
    }
  }, function($a, $param, $body) {
    return AST["catch"]($param, T.transform(AST.assign($a.name, $body)));
  });

  T.register('procedure', function($p) {
    return [$p.name, $p.params, $p.body, $p.returns];
  }, function($p, $name, $params, $body, $returns) {
    /*
      newParams = 
        for param in $params 
          CLONE.transform param
      locals = 
        for param, i in $params 
          AST.local param.name, newParams[i].ref()
      body = 
        if $body.type() == 'block'
          AST.block locals.concat($body.items)
        else
          AST.block locals.concat($body)
    */

    var body;
    body = T.transform(AST["return"]($body));
    body = body.type() === 'block' ? body : AST.block([body]);
    $p.body = body;
    return TCO.transform($p);
  });

  T.register('task', function($p) {
    return [$p.name, $p.params, $p.body, $p.returns];
  }, function($p, $name, $params, $body, $returns) {
    var body;
    body = T.transform(AST["return"]($body));
    return CPS.transform(AST.task($name, $params, body, $returns));
  });

  T.register('toplevel', function($t) {
    return [$t.body];
  }, function($t, $body) {
    var body;
    body = T.transform($body);
    return CPS.transform($t.clone(body));
  });

  T.register('module', function($t) {
    return [$t.body];
  }, function($t, $body) {
    var body;
    body = T.transform($body);
    return CPS.transform($t.clone(body));
  });

}).call(this);
