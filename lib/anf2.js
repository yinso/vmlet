// Generated by CoffeeScript 1.4.0
(function() {
  var AST, Environment, LexicalEnvironment, ParamList, assign, baseEnv, errorlet, get, loglet, makeProc, normalize, override, register, transform, transformArray, transformBinary, transformBlock, transformCatch, transformDefine, transformFinally, transformFuncall, transformIdentifier, transformIf, transformMember, transformObject, transformParam, transformScalar, transformTaskcall, transformTempVar, transformThrow, transformTry, types, _transform;

  loglet = require('loglet');

  errorlet = require('errorlet');

  AST = require('./ast');

  baseEnv = require('./baseenv');

  Environment = require('./environment');

  ParamList = require('./parameter');

  LexicalEnvironment = require('./lexical');

  types = {};

  register = function(ast, transformer) {
    if (types.hasOwnProperty(ast.type)) {
      throw errorlet.create({
        error: 'block_duplicate_ast_type',
        type: ast.type
      });
    } else {
      return types[ast.type] = transformer;
    }
  };

  get = function(ast) {
    if (types.hasOwnProperty(ast.constructor.type)) {
      return types[ast.constructor.type];
    } else {
      throw errorlet.create({
        error: 'block_unsupported_ast_type',
        type: ast.constructor.type
      });
    }
  };

  override = function(ast, transformer) {
    return types[ast.type] = transformer;
  };

  assign = function(ast, env, block, sym) {
    var varName;
    if (sym == null) {
      sym = LexicalEnvironment.defaultPrefix;
    }
    varName = env.assign(ast, sym);
    block.push(AST.make('tempvar', varName, ast));
    return AST.make('symbol', varName);
  };

  normalize = function(block) {
    var res;
    loglet.log('normalize', block);
    if (block.items.length === 1) {
      res = block.items[0];
      if (res.type() === 'tempvar') {
        return res.val;
      } else {
        return res;
      }
    } else {
      return block;
    }
  };

  transform = function(ast, env, block) {
    if (env == null) {
      env = new LexicalEnvironment({}, baseEnv);
    }
    if (block == null) {
      block = AST.make('block', []);
    }
    _transform(ast, env, block);
    return normalize(block);
  };

  _transform = function(ast, env, block) {
    var transformer;
    transformer = get(ast);
    return transformer(ast, env, block);
  };

  transformScalar = function(ast, env, block) {
    return block.push(ast);
  };

  register(AST.get('number'), transformScalar);

  register(AST.get('bool'), transformScalar);

  register(AST.get('null'), transformScalar);

  register(AST.get('string'), transformScalar);

  transformBinary = function(ast, env, block) {
    var lhs, rhs;
    loglet.log('--block.transformBinary', ast);
    lhs = transform(ast.lhs, env);
    rhs = transform(ast.rhs, env);
    return assign(AST.make('binary', ast.op, lhs, rhs), env, block);
  };

  register(AST.get('binary'), transformBinary);

  transformIf = function(ast, env, block) {
    var cond, elseAST, thenAST;
    loglet.log('--block.transformIf', ast, env, block);
    cond = transform(ast["if"], env);
    thenAST = transform(ast.then, env);
    elseAST = transform(ast["else"], env);
    return assign(AST.make('if', cond, thenAST, elseAST), env, block);
  };

  register(AST.get('if'), transformIf);

  transformBlock = function(ast, env, block) {
    var i, newEnv, res, _i, _ref;
    newEnv = new LexicalEnvironment({}, env);
    for (i = _i = 0, _ref = ast.items.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _transform(ast.items[i], newEnv, block);
    }
    res = _transform(ast.items[ast.items.length - 1], newEnv, block);
    return res;
  };

  register(AST.get('block'), transformBlock);

  transformDefine = function(ast, env, block) {
    var res;
    loglet.log('transformDefine', ast);
    if (env.level() > 0) {
      return transformTempVar(ast, env, block);
    } else {
      res = _transform(ast.val, env, block);
      env.define(ast.name, res);
      block.push(AST.make('define', ast.name, res));
      return res;
    }
  };

  register(AST.get('define'), transformDefine);

  transformTempVar = function(ast, env, block) {
    var local, res;
    res = _transform(ast.val, env, block);
    local = assign(res, env, block);
    env.mapLocal(ast.name, local.val);
    return local;
  };

  register(AST.get('tempvar'), transformTempVar);

  transformIdentifier = function(ast, env, block) {
    loglet.log('--block.transformIdentifier', ast, env);
    if (env.hasLocal(ast.val)) {
      return block.push(env.getLocal(ast.val));
    } else if (env.has(ast.val)) {
      loglet.log('--block.transformIdentifier.env.has', ast, env, env.get(ast.val));
      return block.push(AST.make('proxyval', ast.val, env.get(ast.val), function(ast) {
        return "_rt.get(" + (JSON.stringify(ast.name)) + ")";
      }));
    } else {
      throw errorlet.create({
        error: 'ANF.transform:unknown_identifier',
        id: ast.val
      });
    }
  };

  register(AST.get('symbol'), transformIdentifier);

  transformObject = function(ast, env, block) {
    var key, keyVals, v, val;
    keyVals = (function() {
      var _i, _len, _ref, _ref1, _results;
      _ref = ast.val;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], key = _ref1[0], val = _ref1[1];
        v = _transform(val, env, block);
        _results.push([key, v]);
      }
      return _results;
    })();
    return assign(AST.make('object', keyVals), env, block);
  };

  register(AST.get('object'), transformObject);

  transformArray = function(ast, env, block) {
    var items, v;
    items = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.val;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(_transform(v, env, block));
      }
      return _results;
    })();
    return assign(AST.make('array', items), env, block);
  };

  register(AST.get('array'), transformArray);

  transformMember = function(ast, env, block) {
    var head;
    head = _transform(ast.head, env, block);
    return assign(AST.make('member', head, ast.key), env, block);
  };

  register(AST.get('member'), transformMember);

  transformFuncall = function(ast, env, block) {
    var arg, args, funcall;
    loglet.log('--anf.transformFuncall', ast, block);
    args = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.args;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        _results.push(_transform(arg, env, block));
      }
      return _results;
    })();
    funcall = _transform(ast.funcall, env, block);
    ast = AST.make('funcall', funcall, args);
    return assign(ast, env, block);
  };

  register(AST.get('funcall'), transformFuncall);

  transformTaskcall = function(ast, env, block) {
    var arg, args, funcall;
    loglet.log('--anf.transformTaskcall', ast, block);
    args = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.args;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        _results.push(_transform(arg, env, block));
      }
      return _results;
    })();
    funcall = _transform(ast.funcall, env, block);
    return assign(AST.make('taskcall', funcall, args), env, block);
  };

  register(AST.get('taskcall'), transformTaskcall);

  transformParam = function(ast, env, block) {
    return ast;
  };

  register(AST.get('param'), transformParam);

  makeProc = function(type) {
    return function(ast, env, block) {
      var body, name, newEnv, param, params;
      newEnv = new LexicalEnvironment({}, env);
      name = ast.name ? newEnv.defineRef(ast.name) : void 0;
      params = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.params;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          param = _ref[_i];
          _results.push(newEnv.mapParam(param));
        }
        return _results;
      })();
      body = transform(ast.body, newEnv);
      ast = AST.make(type, name, params, body);
      return assign(ast, env, block);
    };
  };

  register(AST.get('procedure'), makeProc('procedure'));

  register(AST.get('task'), makeProc('task'));

  transformThrow = function(ast, env, block) {
    var exp;
    exp = _transform(ast.val, env, block);
    return block.push(AST.make('throw', exp));
  };

  register(AST.get('throw'), transformThrow);

  transformCatch = function(ast, env, block) {
    var body, newEnv, param;
    loglet.log('--anf.transformCatch', ast);
    newEnv = new LexicalEnvironment({}, env);
    param = newEnv.mapParam(ast.param);
    body = transform(ast.body, newEnv);
    return AST.make('catch', param, body);
  };

  transformFinally = function(ast, env, block) {
    var body, newEnv;
    loglet.log('--anf.transformFinally', ast);
    newEnv = new LexicalEnvironment({}, env);
    body = transform(ast.body, newEnv);
    return AST.make('finally', body);
  };

  transformTry = function(ast, env, block) {
    var body, c, catches, fin, newEnv;
    loglet.log('--anf.transformTry', ast);
    newEnv = new LexicalEnvironment({}, env);
    body = transform(ast.body, newEnv);
    catches = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.catches;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(transformCatch(c, env, block));
      }
      return _results;
    })();
    fin = ast["finally"] instanceof AST ? transformFinally(ast["finally"], env, block) : null;
    loglet.log('--anf.transformTry', body, catches, fin);
    return block.push(AST.make('try', body, catches, fin));
  };

  register(AST.get('try'), transformTry);

  module.exports = {
    register: register,
    get: get,
    override: override,
    transform: transform
  };

}).call(this);
