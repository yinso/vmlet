// Generated by CoffeeScript 1.4.0
(function() {
  var AST, Environment, Hashmap, Registry, T, TR, util;

  AST = require('./ast');

  Hashmap = require('./hashmap');

  util = require('./util');

  T = require('./transformer');

  TR = require('./trace');

  Environment = (function() {

    function Environment() {
      this.inner = new Hashmap();
      this.temp = 0;
    }

    Environment.prototype.has = function(key) {
      return this.inner.has(key);
    };

    Environment.prototype.get = function(key) {
      return this.inner.get(key);
    };

    Environment.prototype.set = function(key, val) {
      return this.inner.set(key, val);
    };

    Environment.prototype.alias = function(key) {
      var ref;
      if (this.has(key)) {
        return this.get(key);
      } else {
        ref = AST.ref(key);
        this.set(key, ref);
        return ref;
      }
    };

    Environment.prototype.gensym = function(sym) {
      if (sym == null) {
        sym = null;
      }
      if (sym) {
        return AST.symbol("" + sym.value + "$" + (this.temp++));
      } else {
        return AST.symbol("_$" + (this.temp++));
      }
    };

    Environment.prototype.defineTemp = function(ast) {
      var ref, sym;
      sym = this.gensym();
      ref = this.alias(sym);
      ref.value = ast;
      return ref;
    };

    Environment.prototype.toString = function() {
      return "<env>";
    };

    return Environment;

  })();

  Registry = (function() {
    var _let;

    function Registry() {}

    Registry.transform = function(ast) {
      if (!this.reg) {
        this.reg = new this();
      }
      return this.reg.transform(ast);
    };

    Registry.prototype.transform = function(ast, env, block) {
      var res;
      if (env == null) {
        env = new Environment();
      }
      if (block == null) {
        block = AST.block();
      }
      res = this._transInner(ast, env, block);
      return T.transform(res);
    };

    Registry.prototype._transInner = function(ast, env, block) {
      var res;
      if (block == null) {
        block = AST.block();
      }
      res = this._trans(ast, env, block);
      return this._normalize(res, block);
    };

    Registry.prototype._normalize = function(ast, block) {
      switch (ast.type()) {
        case 'toplevel':
        case 'module':
          return ast;
        default:
          return this._normalizeBlock(block);
      }
    };

    Registry.prototype._normalizeBlock = function(ast) {
      var i, item, items, _i, _len, _ref;
      items = [];
      _ref = ast.items;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        item = _ref[i];
        if (i < ast.items.length - 1) {
          switch (item.type()) {
            case 'number':
            case 'string':
            case 'bool':
            case 'null':
            case 'unit':
            case 'proxyval':
            case 'ref':
            case 'symbol':
              item;

              break;
            default:
              items.push(item);
          }
        } else {
          items.push(item);
        }
      }
      return AST.block(items);
    };

    Registry.prototype._trans = function(ast, env, block) {
      var type;
      if (block == null) {
        block = AST.block();
      }
      type = "_" + (ast.type());
      if (this[type]) {
        return this[type](ast, env, block);
      } else {
        throw new Error("anf.unknown_type: " + (ast.type()));
      }
    };

    Registry.prototype.assign = function(ast, env, block) {
      var sym;
      sym = env.defineTemp(ast);
      block.push(AST.local(sym, ast));
      return sym;
    };

    Registry.prototype._number = function(ast, env, block) {
      return block.push(ast);
    };

    Registry.prototype._string = function(ast, env, block) {
      return block.push(ast);
    };

    Registry.prototype._bool = function(ast, env, block) {
      return block.push(ast);
    };

    Registry.prototype._null = function(ast, env, block) {
      return block.push(ast);
    };

    Registry.prototype._unit = function(ast, env, block) {
      return block.push(ast);
    };

    Registry.prototype._symbol = function(ast, env, block) {
      var ref;
      ref = env.alias(ast);
      return ref.name;
    };

    Registry.prototype._ref = function(ast, env, block) {
      var ref;
      ref = env.alias(ast.name);
      ref.value = ast.value;
      return block.push(ref);
    };

    Registry.prototype._binary = function(ast, env, block) {
      var lhs, rhs;
      lhs = this._trans(ast.lhs, env, block);
      rhs = this._trans(ast.rhs, env, block);
      return this.assign(AST.binary(ast.op, lhs, rhs), env, block);
    };

    Registry.prototype._if = function(ast, env, block) {
      var cond, elseAST, thenAST;
      cond = this._trans(ast.cond, env, block);
      thenAST = this._transInner(ast.then, env);
      elseAST = this._transInner(ast["else"], env);
      return this.assign(AST["if"](cond, thenAST, elseAST), env, block);
    };

    Registry.prototype._block = function(ast, env, block) {
      var i, res, _i, _ref;
      for (i = _i = 0, _ref = ast.items.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this._trans(ast.items[i], env, block);
      }
      res = this._trans(ast.items[ast.items.length - 1], env, block);
      return res;
    };

    Registry.prototype._define = function(ast, env, block) {
      var exp, i, ref, res, _i, _len, _ref, _results;
      ref = this._trans(ast.name, env, block);
      if (ref.type() === 'symbol') {
        ref = env.get(ref);
      }
      res = this._transInner(ast.value, env);
      if (res.type() === 'block') {
        _ref = res.items;
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          exp = _ref[i];
          if (i < res.items.length - 1) {
            _results.push(block.push(exp));
          } else {
            switch (exp.type()) {
              case 'define':
              case 'local':
                ref.value = exp.value;
                _results.push(block.push(AST.define(ref, exp.value)));
                break;
              default:
                ref.value = exp;
                _results.push(block.push(AST.define(ref, exp)));
            }
          }
        }
        return _results;
      } else {
        ref.value = exp;
        return block.push(AST.define(ref, res));
      }
    };

    Registry.prototype._local = function(ast, env, block) {
      var cloned, exp, i, ref, res, _i, _len, _ref, _results;
      ref = this._trans(ast.name, env, block);
      if (ref.type() === 'symbol') {
        ref = env.get(ref);
      }
      res = ast.value ? this._transInner(ast.value, env) : ast.value;
      if ((res != null ? res.type() : void 0) === 'block') {
        _ref = res.items;
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          exp = _ref[i];
          if (i < res.items.length - 1) {
            _results.push(block.push(exp));
          } else {
            switch (exp.type()) {
              case 'define':
              case 'local':
                ref.value = exp.value;
                _results.push(block.push(AST.local(ref, exp.value)));
                break;
              default:
                ref.value = exp;
                _results.push(block.push(AST.local(ref, exp)));
            }
          }
        }
        return _results;
      } else {
        ref.value = res;
        cloned = AST.local(ref, res);
        return block.push(cloned);
      }
    };

    Registry.prototype._object = function(ast, env, block) {
      var key, keyVals, v, val;
      keyVals = (function() {
        var _i, _len, _ref, _ref1, _results;
        _ref = ast.value;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], key = _ref1[0], val = _ref1[1];
          v = this._trans(val, env, block);
          _results.push([key, v]);
        }
        return _results;
      }).call(this);
      return this.assign(AST.object(keyVals), env, block);
    };

    Registry.prototype._array = function(ast, env, block) {
      var items, v;
      items = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.value;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          _results.push(this._trans(v, env, block));
        }
        return _results;
      }).call(this);
      return this.assign(AST.array(items), env, block);
    };

    Registry.prototype._member = function(ast, env, block) {
      var head;
      head = this._trans(ast.head, env, block);
      return this.assign(AST.member(head, ast.key), env, block);
    };

    Registry.prototype._funcall = function(ast, env, block) {
      var arg, args, funcall;
      funcall = this._trans(ast.funcall, env, block);
      args = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.args;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          arg = _ref[_i];
          _results.push(this._trans(arg, env, block));
        }
        return _results;
      }).call(this);
      ast = AST.funcall(funcall, args);
      return this.assign(ast, env, block);
    };

    Registry.prototype._taskcall = function(ast, env, block) {
      var arg, args, funcall;
      funcall = this._trans(ast.funcall, env, block);
      args = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.args;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          arg = _ref[_i];
          _results.push(this._trans(arg, env, block));
        }
        return _results;
      }).call(this);
      return this.assign(AST.taskcall(funcall, args), env, block);
    };

    Registry._proc = function(type) {
      return function(ast, env, block) {
        var newEnv, p, params, proc, ref;
        newEnv = env;
        ref = ast.name ? this._trans(ast.name, newEnv) : void 0;
        params = (function() {
          var _i, _len, _ref, _results;
          _ref = ast.params;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            p = _ref[_i];
            _results.push(this._trans(p, newEnv));
          }
          return _results;
        }).call(this);
        proc = AST.make(type, ref, params);
        if (ref) {
          ref.value = proc;
        }
        proc.body = this._transInner(ast.body, newEnv);
        return block.push(T.transform(proc));
      };
    };

    Registry.prototype._procedure = Registry._proc('procedure');

    Registry.prototype._task = Registry._proc('task');

    Registry.prototype._param = function(ast, env, block) {
      var name, param, ref;
      name = this._trans(ast.name, env, block);
      param = AST.param(name, ast.type, ast["default"]);
      ref = env.alias(name);
      ref.value = param;
      return param;
    };

    Registry.prototype._throw = function(ast, env, block) {
      var exp;
      exp = this._trans(ast.value, env, block);
      return block.push(AST["throw"](exp));
    };

    Registry.prototype._catch = function(ast, env, block) {
      var body, newEnv, param;
      newEnv = env;
      param = this._trans(ast.param, newEnv);
      body = this._trans(ast.body, newEnv);
      return AST["catch"](param, body);
    };

    Registry.prototype._finally = function(ast, env, block) {
      var body, newEnv;
      newEnv = env;
      body = this.transform(ast.body, newEnv);
      return AST["finally"](body);
    };

    Registry.prototype._try = function(ast, env, block) {
      var body, c, catches, fin, newEnv;
      newEnv = env;
      body = this._trans(ast.body, newEnv);
      catches = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.catches;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          _results.push(this._catch(c, env, block));
        }
        return _results;
      }).call(this);
      fin = ast["finally"] ? this._finally(ast["finally"], env, block) : null;
      return block.push(AST["try"](body, catches, fin));
    };

    Registry.prototype._import = function(ast, env, block) {
      var binding, defines;
      defines = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.bindings;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          binding = _ref[_i];
          _results.push(this._trans(ast.define(binding), env, block));
        }
        return _results;
      }).call(this);
      return block.push(AST.unit());
    };

    Registry.prototype._export = function(ast, env, block) {
      var binding, bindings, spec;
      bindings = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.bindings;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          binding = _ref[_i];
          spec = this._trans(binding.spec, env, block);
          _results.push(AST.binding(spec, binding.as));
        }
        return _results;
      }).call(this);
      return block.push(AST["export"](bindings));
    };

    _let = function(ast, env, block) {
      var body, define, defines, exp, newEnv, res, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
      newEnv = env;
      defines = [];
      _ref = ast.defines;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        define = _ref[_i];
        res = this._trans(define, newEnv);
        _ref1 = res.items;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          exp = _ref1[_j];
          block.push(exp);
        }
      }
      body = this._trans(ast.body, newEnv);
      if (body.type() === 'block') {
        _ref2 = body.items;
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          exp = _ref2[_k];
          _results.push(block.push(exp));
        }
        return _results;
      } else {
        return block.push(body);
      }
    };

    Registry.prototype._toplevel = function(ast, env, block) {
      var body;
      body = this._transInner(ast.body, env, block);
      return ast.clone(AST["return"](body));
    };

    Registry.prototype._module = function(ast, env, block) {
      var body;
      body = this._transInner(ast.body, env, block);
      return ast.clone(AST["return"](body));
    };

    return Registry;

  })();

  module.exports = Registry;

}).call(this);
