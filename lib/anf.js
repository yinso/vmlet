// Generated by CoffeeScript 1.4.0
(function() {
  var AST, Environment, T, assign, get, register, transform, types, _alias, _array, _binary, _block, _catch, _define, _export, _finally, _funcall, _if, _import, _let, _local, _member, _module, _normalize, _normalizeBlock, _object, _param, _proc, _ref, _scalar, _symbol, _taskcall, _throw, _toplevel, _trans, _transInner, _try;

  AST = require('./ast');

  Environment = require('./environment');

  T = require('./transformer');

  types = {};

  register = function(type, transformer) {
    if (types.hasOwnProperty(type.type)) {
      throw new Error("ANF.duplicate_type: " + type.type);
    }
    return types[type.type] = transformer;
  };

  get = function(ast) {
    if (types.hasOwnProperty(ast.type())) {
      return types[ast.type()];
    } else {
      throw new Error("ANF.unknown_type: " + (ast.type()));
    }
  };

  transform = function(ast, env, block) {
    var res;
    if (env == null) {
      env = new Environment();
    }
    if (block == null) {
      block = AST.block();
    }
    res = _transInner(ast, env, block);
    return T.transform(res);
  };

  _normalize = function(ast, block) {
    switch (ast.type()) {
      case 'toplevel':
      case 'module':
        return ast;
      default:
        return _normalizeBlock(block);
    }
  };

  _transInner = function(ast, env, block) {
    var res;
    if (block == null) {
      block = AST.block();
    }
    res = _trans(ast, env, block);
    return _normalize(res, block);
  };

  _normalizeBlock = function(ast) {
    var i, item, items, _i, _len, _ref;
    items = [];
    _ref = ast.items;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      item = _ref[i];
      if (i < ast.items.length - 1) {
        switch (item.type()) {
          case 'number':
          case 'string':
          case 'bool':
          case 'null':
          case 'unit':
          case 'proxyval':
          case 'ref':
          case 'symbol':
            item;

            break;
          default:
            items.push(item);
        }
      } else {
        items.push(item);
      }
    }
    return AST.block(items);
  };

  _trans = function(ast, env, block) {
    var trans;
    if (block == null) {
      block = AST.block();
    }
    trans = get(ast);
    return trans(ast, env, block);
  };

  assign = function(ast, env, block) {
    var sym;
    sym = env.defineTemp(ast);
    block.push(AST.local(sym, ast));
    return sym;
  };

  _scalar = function(ast, env, block) {
    return block.push(ast);
  };

  register(AST.get('number'), _scalar);

  register(AST.get('string'), _scalar);

  register(AST.get('bool'), _scalar);

  register(AST.get('null'), _scalar);

  register(AST.get('unit'), _scalar);

  register(AST.get('proxyval'), _scalar);

  _alias = function(ast, env) {
    switch (ast.type()) {
      case 'ref':
        if (env.has(ast.name)) {
          return env.get(ast.name);
        } else {
          return env.define(ast.name, ast.value);
        }
        break;
      case 'symbol':
        if (env.has(ast)) {
          return env.get(ast);
        } else {
          return env.define(ast);
        }
        break;
      default:
        throw new Error("ANF.alias:unsuppoted_type: " + ast);
    }
  };

  _symbol = function(ast, env, block) {
    return _alias(ast, env);
  };

  register(AST.get('symbol'), _symbol);

  _ref = function(ast, env, block) {
    var ref;
    ref = _alias(ast, env);
    return block.push(ref);
  };

  register(AST.get('ref'), _ref);

  _binary = function(ast, env, block) {
    var lhs, rhs;
    lhs = _trans(ast.lhs, env, block);
    rhs = _trans(ast.rhs, env, block);
    return assign(AST.binary(ast.op, lhs, rhs), env, block);
  };

  register(AST.get('binary'), _binary);

  _if = function(ast, env, block) {
    var cond, elseAST, thenAST;
    cond = _trans(ast.cond, env, block);
    thenAST = _transInner(ast.then, env);
    elseAST = _transInner(ast["else"], env);
    return assign(AST["if"](cond, thenAST, elseAST), env, block);
  };

  register(AST.get('if'), _if);

  _block = function(ast, env, block) {
    var i, res, _i, _ref1;
    for (i = _i = 0, _ref1 = ast.items.length - 1; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
      _trans(ast.items[i], env, block);
    }
    res = _trans(ast.items[ast.items.length - 1], env, block);
    return res;
  };

  register(AST.get('block'), _block);

  _define = function(ast, env, block) {
    var exp, i, ref, res, _i, _len, _ref1, _results;
    ref = _alias(ast.name, env, block);
    res = _transInner(ast.value, env);
    if (res.type() === 'block') {
      _ref1 = res.items;
      _results = [];
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        exp = _ref1[i];
        if (i < res.items.length - 1) {
          _results.push(block.push(exp));
        } else {
          switch (exp.type()) {
            case 'define':
            case 'local':
              ref.value = exp.value;
              _results.push(block.push(AST.define(ref, exp.value)));
              break;
            default:
              ref.value = exp;
              _results.push(block.push(AST.define(ref, exp)));
          }
        }
      }
      return _results;
    } else {
      ref.value = exp;
      return block.push(AST.define(ref, res));
    }
  };

  register(AST.get('define'), _define);

  _local = function(ast, env, block) {
    var cloned, exp, i, ref, res, _i, _len, _ref1, _results;
    ref = _alias(ast.name, env, block);
    res = ast.value ? _transInner(ast.value, env) : ast.value;
    if (res.type() === 'block') {
      _ref1 = res.items;
      _results = [];
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        exp = _ref1[i];
        if (i < res.items.length - 1) {
          _results.push(block.push(exp));
        } else {
          switch (exp.type()) {
            case 'define':
            case 'local':
              ref.value = exp.value;
              _results.push(block.push(AST.local(ref, exp.value)));
              break;
            default:
              ref.value = exp;
              _results.push(block.push(AST.local(ref, exp)));
          }
        }
      }
      return _results;
    } else {
      ref.value = res;
      cloned = AST.local(ref, res);
      return block.push(cloned);
    }
  };

  register(AST.get('local'), _local);

  _object = function(ast, env, block) {
    var key, keyVals, v, val;
    keyVals = (function() {
      var _i, _len, _ref1, _ref2, _results;
      _ref1 = ast.value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], key = _ref2[0], val = _ref2[1];
        v = _trans(val, env, block);
        _results.push([key, v]);
      }
      return _results;
    })();
    return assign(AST.object(keyVals), env, block);
  };

  register(AST.get('object'), _object);

  _array = function(ast, env, block) {
    var items, v;
    items = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = ast.value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        v = _ref1[_i];
        _results.push(_trans(v, env, block));
      }
      return _results;
    })();
    return assign(AST.array(items), env, block);
  };

  register(AST.get('array'), _array);

  _member = function(ast, env, block) {
    var head;
    head = _trans(ast.head, env, block);
    return assign(AST.member(head, ast.key), env, block);
  };

  register(AST.get('member'), _member);

  _funcall = function(ast, env, block) {
    var arg, args, funcall;
    args = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = ast.args;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        arg = _ref1[_i];
        _results.push(_trans(arg, env, block));
      }
      return _results;
    })();
    funcall = _trans(ast.funcall, env, block);
    ast = AST.funcall(funcall, args);
    return assign(ast, env, block);
  };

  register(AST.get('funcall'), _funcall);

  _taskcall = function(ast, env, block) {
    var arg, args, funcall;
    args = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = ast.args;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        arg = _ref1[_i];
        _results.push(_trans(arg, env, block));
      }
      return _results;
    })();
    funcall = _trans(ast.funcall, env, block);
    return assign(AST.taskcall(funcall, args), env, block);
  };

  register(AST.get('taskcall'), _taskcall);

  _proc = function(type) {
    return function(ast, env, block) {
      var newEnv, p, params, proc, ref;
      newEnv = new Environment(env);
      ref = ast.name ? _trans(ast.name, newEnv) : void 0;
      params = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = ast.params;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          p = _ref1[_i];
          _results.push(_trans(p, newEnv));
        }
        return _results;
      })();
      proc = AST.make(type, ref, params);
      if (ref) {
        ref.value = proc;
      }
      proc.body = _transInner(ast.body, newEnv);
      return block.push(T.transform(proc));
    };
  };

  register(AST.get('procedure'), _proc('procedure'));

  register(AST.get('task'), _proc('task'));

  _param = function(ast, env, block) {
    var ref;
    ref = _alias(ast.name, env, block);
    ref.value = AST.param(ref, ast.type, ast["default"]);
    return ref.value;
  };

  register(AST.get('param'), _param);

  _throw = function(ast, env, block) {
    var exp;
    exp = _trans(ast.value, env, block);
    return block.push(AST["throw"](exp));
  };

  register(AST.get('throw'), _throw);

  _catch = function(ast, env, block) {
    var body, newEnv, param;
    newEnv = new Environment(env);
    param = _trans(ast.param, newEnv);
    body = _trans(ast.body, newEnv);
    return AST["catch"](param, body);
  };

  register(AST.get('catch'), _catch);

  _finally = function(ast, env, block) {
    var body, newEnv;
    newEnv = new Environment(env);
    body = transform(ast.body, newEnv);
    return AST["finally"](body);
  };

  _try = function(ast, env, block) {
    var body, c, catches, fin, newEnv;
    newEnv = new Environment(env);
    body = _trans(ast.body, newEnv);
    catches = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = ast.catches;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        c = _ref1[_i];
        _results.push(_catch(c, env, block));
      }
      return _results;
    })();
    fin = ast["finally"] ? _finally(ast["finally"], env, block) : null;
    return block.push(AST["try"](body, catches, fin));
  };

  register(AST.get('try'), _try);

  _import = function(ast, env, block) {
    var binding, defines;
    defines = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = ast.bindings;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        binding = _ref1[_i];
        _results.push(_trans(ast.define(binding), env, block));
      }
      return _results;
    })();
    return block.push(AST.unit());
  };

  register(AST.get('import'), _import);

  _export = function(ast, env, block) {
    var binding, bindings, spec;
    bindings = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = ast.bindings;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        binding = _ref1[_i];
        spec = _trans(binding.spec, env, block);
        _results.push(AST.binding(spec, binding.as));
      }
      return _results;
    })();
    return block.push(AST["export"](bindings));
  };

  register(AST.get('export'), _export);

  _let = function(ast, env, block) {
    var body, define, defines, exp, newEnv, res, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _results;
    newEnv = new Environment(env);
    defines = [];
    _ref1 = ast.defines;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      define = _ref1[_i];
      res = _trans(define, newEnv);
      _ref2 = res.items;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        exp = _ref2[_j];
        block.push(exp);
      }
    }
    body = _trans(ast.body, newEnv);
    if (body.type() === 'block') {
      _ref3 = body.items;
      _results = [];
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        exp = _ref3[_k];
        _results.push(block.push(exp));
      }
      return _results;
    } else {
      return block.push(body);
    }
  };

  register(AST.get('let'), _let);

  _toplevel = function(ast, env, block) {
    var body;
    body = _transInner(ast.body, env, block);
    return ast.clone(AST["return"](body));
  };

  register(AST.get('toplevel'), _toplevel);

  _module = function(ast, env, block) {
    var body;
    body = _transInner(ast.body, env, block);
    return ast.clone(AST["return"](body));
  };

  register(AST.get('module'), _module);

  module.exports = {
    register: register,
    get: get,
    transform: transform
  };

}).call(this);
