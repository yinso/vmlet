// Generated by CoffeeScript 1.4.0
(function() {
  var AST, Environment, assign, errorlet, get, makeProc, normalize, normalizeBlock, override, register, tr, transform, transformArray, transformBinary, transformBlock, transformCatch, transformDefine, transformFinally, transformFuncall, transformIdentifier, transformIf, transformLocal, transformMember, transformObject, transformParam, transformProc, transformScalar, transformTaskcall, transformThrow, transformTry, _transTypes, _transform, _transformInner;

  errorlet = require('errorlet');

  AST = require('./ast');

  Environment = require('./symboltable');

  tr = require('./trace');

  _transTypes = {};

  register = function(ast, transformer) {
    if (_transTypes.hasOwnProperty(ast.type)) {
      throw errorlet.create({
        error: 'anf_duplicate_ast_type',
        type: ast.type
      });
    } else {
      return _transTypes[ast.type] = transformer;
    }
  };

  get = function(ast) {
    if (_transTypes.hasOwnProperty(ast.constructor.type)) {
      return _transTypes[ast.constructor.type];
    } else {
      throw errorlet.create({
        error: 'anf_unsupported_ast_type',
        type: ast.constructor.type
      });
    }
  };

  override = function(ast, transformer) {
    return _transTypes[ast.type] = transformer;
  };

  assign = function(ast, env, block) {
    var sym;
    sym = env.defineTemp(ast);
    block.push(AST.local(sym, ast));
    return sym;
  };

  normalize = function(ast) {
    switch (ast.type()) {
      case 'block':
        return normalizeBlock(ast);
      default:
        return ast;
    }
  };

  normalizeBlock = function(ast) {
    var i, item, items, _i, _len, _ref;
    items = [];
    _ref = ast.items;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      item = _ref[i];
      if (i < ast.items.length - 1) {
        switch (item.type()) {
          case 'local':
          case 'define':
            items.push(item);
        }
      } else {
        items.push((function() {
          switch (item.type()) {
            case 'local':
              return item.value;
            case 'define':
              return item.value;
            default:
              return item;
          }
        })());
      }
    }
    if (items.length === 1) {
      return items[0];
    } else {
      return AST.block(items);
    }
  };

  transform = function(ast, env, block) {
    if (block == null) {
      block = AST.block([]);
    }
    _transform(ast, env, block);
    return normalize(block);
  };

  _transformInner = function(ast, env, block) {
    if (block == null) {
      block = AST.block();
    }
    _transform(ast, env, block);
    return block;
  };

  _transform = function(ast, env, block) {
    var transformer;
    if (block == null) {
      block = AST.block();
    }
    transformer = get(ast);
    return transformer(ast, env, block);
  };

  transformScalar = function(ast, env, block) {
    return block.push(ast);
  };

  register(AST.get('number'), transformScalar);

  register(AST.get('bool'), transformScalar);

  register(AST.get('null'), transformScalar);

  register(AST.get('string'), transformScalar);

  register(AST.get('ref'), transformScalar);

  transformProc = function(ast, env, block) {
    return assign(ast, env, block);
  };

  register(AST.get('procedure'), transformProc);

  register(AST.get('task'), transformProc);

  transformBinary = function(ast, env, block) {
    var lhs, rhs;
    lhs = _transform(ast.lhs, env, block);
    rhs = _transform(ast.rhs, env, block);
    return assign(AST.binary(ast.op, lhs, rhs), env, block);
  };

  register(AST.get('binary'), transformBinary);

  transformIf = function(ast, env, block) {
    var cond, elseAST, thenAST;
    cond = _transform(ast.cond, env, block);
    thenAST = _transformInner(ast.then, env);
    elseAST = _transformInner(ast["else"], env);
    return assign(AST["if"](cond, thenAST, elseAST), env, block);
  };

  register(AST.get('if'), transformIf);

  transformBlock = function(ast, env, block) {
    var i, newEnv, res, _i, _ref;
    newEnv = new Environment(env);
    for (i = _i = 0, _ref = ast.items.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _transform(ast.items[i], newEnv, block);
    }
    res = _transform(ast.items[ast.items.length - 1], newEnv, block);
    return res;
  };

  register(AST.get('block'), transformBlock);

  transformDefine = function(ast, env, block) {
    var res;
    console.log('ANF.define', ast);
    res = transform(ast.value, env);
    block.push(AST.define(ast.name, res));
    return res;
  };

  register(AST.get('define'), transformDefine);

  transformLocal = tr.trace('anf.local', function(ast, env, block) {
    var cloned, res;
    res = transform(ast.normalized(), env);
    cloned = ast.clone(res);
    block.push(cloned);
    return cloned;
  });

  register(AST.get('local'), transformLocal);

  transformIdentifier = function(ast, env, block) {
    return ast;
  };

  register(AST.get('symbol'), transformIdentifier);

  transformObject = function(ast, env, block) {
    var key, keyVals, v, val;
    keyVals = (function() {
      var _i, _len, _ref, _ref1, _results;
      _ref = ast.value;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], key = _ref1[0], val = _ref1[1];
        v = _transform(val, env, block);
        _results.push([key, v]);
      }
      return _results;
    })();
    return assign(AST.object(keyVals), env, block);
  };

  register(AST.get('object'), transformObject);

  transformArray = function(ast, env, block) {
    var items, v;
    items = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.value;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(_transform(v, env, block));
      }
      return _results;
    })();
    return assign(AST.array(items), env, block);
  };

  register(AST.get('array'), transformArray);

  transformMember = function(ast, env, block) {
    var head;
    head = _transform(ast.head, env, block);
    return assign(AST.member(head, ast.key), env, block);
  };

  register(AST.get('member'), transformMember);

  transformFuncall = function(ast, env, block) {
    var arg, args, funcall;
    args = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.args;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        _results.push(_transform(arg, env, block));
      }
      return _results;
    })();
    funcall = _transform(ast.funcall, env, block);
    ast = AST.funcall(funcall, args);
    return assign(ast, env, block);
  };

  register(AST.get('funcall'), transformFuncall);

  transformTaskcall = function(ast, env, block) {
    var arg, args, funcall;
    args = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.args;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        _results.push(_transform(arg, env, block));
      }
      return _results;
    })();
    funcall = _transform(ast.funcall, env, block);
    return assign(AST.taskcall(funcall, args), env, block);
  };

  register(AST.get('taskcall'), transformTaskcall);

  transformParam = function(ast, env, block) {
    return ast;
  };

  register(AST.get('param'), transformParam);

  makeProc = function(type) {
    return function(ast, env, block) {
      var body, newEnv;
      newEnv = new Environment(env);
      body = _transformInner(ast.body, newEnv);
      ast = AST.make(type, ast.name || void 0, ast.params, body);
      return assign(ast, env, block);
    };
  };

  transformThrow = function(ast, env, block) {
    var exp;
    exp = _transform(ast.value, env, block);
    return block.push(AST["throw"](exp));
  };

  register(AST.get('throw'), transformThrow);

  transformCatch = function(ast, env, block) {
    var body, newEnv, ref;
    newEnv = new Environment(env);
    ref = newEnv.defineParam(ast.param);
    body = transform(ast.body, newEnv);
    return AST["catch"](ast.param, body);
  };

  transformFinally = function(ast, env, block) {
    var body, newEnv;
    newEnv = new Environment(env);
    body = transform(ast.body, newEnv);
    return AST["finally"](body);
  };

  transformTry = function(ast, env, block) {
    var body, c, catches, fin, newEnv;
    newEnv = new Environment(env);
    body = transform(ast.body, newEnv);
    catches = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.catches;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(transformCatch(c, env, block));
      }
      return _results;
    })();
    fin = ast["finally"] instanceof AST ? transformFinally(ast["finally"], env, block) : null;
    return block.push(AST["try"](body, catches, fin));
  };

  register(AST.get('try'), transformTry);

  module.exports = {
    register: register,
    get: get,
    override: override,
    transform: transform
  };

}).call(this);
