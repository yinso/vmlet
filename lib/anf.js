// Generated by CoffeeScript 1.4.0
(function() {
  var AST, AnfRegistry, Environment, Hashmap, T, TR, util;

  AST = require('./ast');

  Hashmap = require('./hashmap');

  util = require('./util');

  T = require('./transformer');

  TR = require('./trace');

  /*
  class Environment 
    @make: () -> 
      new @()
    constructor: () -> 
      @inner = new Hashmap()
      @temp = 0
    has: (key) -> 
      @inner.has key 
    get: (key) -> 
      @inner.get key
    set: (key, val) -> 
      @inner.set key, val
    alias: (key) -> 
      if @has key 
        @get key
      else
        ref = AST.ref key # AST.symbol(key.value) # this would have been a new symbol...
        @set key, ref
        ref # this returns a reference... 
    gensym: (sym = null) ->
      if sym 
        AST.symbol "#{sym.value}$#{@temp++}"
      else
        AST.symbol "_$#{@temp++}"
    defineTemp: (ast) -> 
      sym = @gensym()
      ref = @alias sym
      ref.value = ast
      ref
    pushEnv: () -> 
      newEnv = @constructor.make()
      newEnv.prev = @ 
      newEnv
    toString: () -> 
      "<env>"
  */


  Environment = require('./symboltable');

  AnfRegistry = (function() {

    function AnfRegistry() {}

    AnfRegistry.transform = function(ast) {
      if (!this.reg) {
        this.reg = new this();
      }
      return this.reg.transform(ast);
    };

    AnfRegistry.prototype.transform = function(ast, env, block) {
      var res;
      if (env == null) {
        env = Environment.make();
      }
      if (block == null) {
        block = AST.block();
      }
      res = this.runInner(ast, env, block);
      return T.transform(res);
    };

    AnfRegistry.prototype.runInner = function(ast, env, block) {
      var res;
      if (block == null) {
        block = AST.block();
      }
      res = this.run(ast, env, block);
      return this._normalize(res, block);
    };

    AnfRegistry.prototype._normalize = function(ast, block) {
      switch (ast.type()) {
        case 'toplevel':
        case 'module':
          return ast;
        default:
          return this._normalizeBlock(block);
      }
    };

    AnfRegistry.prototype._normalizeBlock = function(ast) {
      var i, item, items, _i, _len, _ref;
      items = [];
      _ref = ast.items;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        item = _ref[i];
        if (i < ast.items.length - 1) {
          switch (item.type()) {
            case 'number':
            case 'string':
            case 'bool':
            case 'null':
            case 'unit':
            case 'proxyval':
            case 'ref':
            case 'symbol':
              item;

              break;
            default:
              items.push(item);
          }
        } else {
          items.push(item);
        }
      }
      return AST.block(items);
    };

    AnfRegistry.prototype.run = function(ast, env, block) {
      var type;
      if (block == null) {
        block = AST.block();
      }
      type = "_" + (ast.type());
      if (this[type]) {
        return this[type](ast, env, block);
      } else {
        throw new Error("anf.unknown_type: " + (ast.type()));
      }
    };

    AnfRegistry.prototype.assign = function(ast, env, block) {
      var sym;
      sym = env.defineTemp(ast);
      block.push(AST.local(sym, ast));
      return sym;
    };

    AnfRegistry.prototype._number = function(ast, env, block) {
      return block.push(ast);
    };

    AnfRegistry.prototype._string = function(ast, env, block) {
      return block.push(ast);
    };

    AnfRegistry.prototype._bool = function(ast, env, block) {
      return block.push(ast);
    };

    AnfRegistry.prototype._null = function(ast, env, block) {
      return block.push(ast);
    };

    AnfRegistry.prototype._unit = function(ast, env, block) {
      return block.push(ast);
    };

    AnfRegistry.prototype._symbol = function(ast, env, block) {
      var ref;
      ref = env.alias(ast);
      return ref.name;
    };

    AnfRegistry.prototype._ref = function(ast, env, block) {
      var ref;
      ref = env.alias(ast.name);
      ref.value = ast.value;
      return block.push(ref);
    };

    AnfRegistry.prototype._binary = function(ast, env, block) {
      var lhs, rhs;
      lhs = this.run(ast.lhs, env, block);
      rhs = this.run(ast.rhs, env, block);
      return this.assign(AST.binary(ast.op, lhs, rhs), env, block);
    };

    AnfRegistry.prototype._if = function(ast, env, block) {
      var cond, elseAST, thenAST;
      cond = this.run(ast.cond, env, block);
      thenAST = this.runInner(ast.then, env);
      elseAST = this.runInner(ast["else"], env);
      return this.assign(AST["if"](cond, thenAST, elseAST), env, block);
    };

    AnfRegistry.prototype._block = function(ast, env, block) {
      var i, res, _i, _ref;
      for (i = _i = 0, _ref = ast.items.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.run(ast.items[i], env, block);
      }
      res = this.run(ast.items[ast.items.length - 1], env, block);
      return res;
    };

    AnfRegistry.prototype._define = function(ast, env, block) {
      var exp, i, ref, res, _i, _len, _ref, _results;
      ref = this.run(ast.name, env, block);
      if (ref.type() === 'symbol') {
        ref = env.get(ref);
      }
      res = this.runInner(ast.value, env);
      if (res.type() === 'block') {
        _ref = res.items;
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          exp = _ref[i];
          if (i < res.items.length - 1) {
            _results.push(block.push(exp));
          } else {
            switch (exp.type()) {
              case 'define':
              case 'local':
                ref.value = exp.value;
                _results.push(block.push(AST.define(ref, exp.value)));
                break;
              default:
                ref.value = exp;
                _results.push(block.push(AST.define(ref, exp)));
            }
          }
        }
        return _results;
      } else {
        ref.value = exp;
        return block.push(AST.define(ref, res));
      }
    };

    AnfRegistry.prototype._local = function(ast, env, block) {
      var cloned, exp, i, ref, res, _i, _len, _ref;
      ref = this.run(ast.name, env, block);
      if (ref.type() === 'symbol') {
        ref = env.get(ref);
      }
      res = ast.value ? this.runInner(ast.value, env) : ast.value;
      if ((res != null ? res.type() : void 0) === 'block') {
        _ref = res.items;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          exp = _ref[i];
          if (i < res.items.length - 1) {
            block.push(exp);
          } else {
            switch (exp.type()) {
              case 'define':
              case 'local':
                ref.value = exp.value;
                return block.push(AST.local(ref, exp.value));
              default:
                ref.value = exp;
                return block.push(AST.local(ref, exp));
            }
          }
        }
      } else {
        ref.value = res;
        cloned = AST.local(ref, res);
        return block.push(cloned);
      }
    };

    AnfRegistry.prototype._object = function(ast, env, block) {
      var key, keyVals, v, val;
      keyVals = (function() {
        var _i, _len, _ref, _ref1, _results;
        _ref = ast.value;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], key = _ref1[0], val = _ref1[1];
          v = this.run(val, env, block);
          _results.push([key, v]);
        }
        return _results;
      }).call(this);
      return this.assign(AST.object(keyVals), env, block);
    };

    AnfRegistry.prototype._array = function(ast, env, block) {
      var items, v;
      items = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.value;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          _results.push(this.run(v, env, block));
        }
        return _results;
      }).call(this);
      return this.assign(AST.array(items), env, block);
    };

    AnfRegistry.prototype._member = function(ast, env, block) {
      var head;
      head = this.run(ast.head, env, block);
      return this.assign(AST.member(head, ast.key), env, block);
    };

    AnfRegistry.prototype._funcall = function(ast, env, block) {
      var arg, args, funcall;
      funcall = this.run(ast.funcall, env, block);
      args = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.args;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          arg = _ref[_i];
          _results.push(this.run(arg, env, block));
        }
        return _results;
      }).call(this);
      ast = AST.funcall(funcall, args);
      return this.assign(ast, env, block);
    };

    AnfRegistry.prototype._taskcall = function(ast, env, block) {
      var arg, args, funcall;
      funcall = this.run(ast.funcall, env, block);
      args = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.args;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          arg = _ref[_i];
          _results.push(this.run(arg, env, block));
        }
        return _results;
      }).call(this);
      return this.assign(AST.taskcall(funcall, args), env, block);
    };

    AnfRegistry._proc = function(type) {
      return function(ast, env, block) {
        var newEnv, p, params, proc, ref;
        newEnv = env;
        ref = ast.name ? this.run(ast.name, newEnv) : void 0;
        params = (function() {
          var _i, _len, _ref, _results;
          _ref = ast.params;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            p = _ref[_i];
            _results.push(this.run(p, newEnv));
          }
          return _results;
        }).call(this);
        proc = AST.make(type, ref, params);
        if (ref) {
          ref.value = proc;
        }
        proc.body = this.runInner(ast.body, newEnv);
        proc.frees = (function() {
          var _i, _len, _ref, _results;
          _ref = ast.frees;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            ref = _ref[_i];
            _results.push(this.run(ref, newEnv));
          }
          return _results;
        }).call(this);
        return block.push(T.transform(proc));
      };
    };

    AnfRegistry.prototype._procedure = AnfRegistry._proc('procedure');

    AnfRegistry.prototype._task = AnfRegistry._proc('task');

    AnfRegistry.prototype._param = function(ast, env, block) {
      var param, ref;
      ref = this.run(ast.name, env, block);
      param = AST.param(ref, ast.type, ast["default"]);
      ref.value = param;
      return param;
    };

    AnfRegistry.prototype._throw = function(ast, env, block) {
      var exp;
      exp = this.run(ast.value, env, block);
      return block.push(AST["throw"](exp));
    };

    AnfRegistry.prototype._catch = function(ast, env, block) {
      var body, newEnv, param;
      newEnv = env;
      param = this.run(ast.param, newEnv);
      body = this.run(ast.body, newEnv);
      return AST["catch"](param, body);
    };

    AnfRegistry.prototype._finally = function(ast, env, block) {
      var body, newEnv;
      newEnv = env;
      body = this.transform(ast.body, newEnv);
      return AST["finally"](body);
    };

    AnfRegistry.prototype._try = function(ast, env, block) {
      var body, c, catches, fin, newEnv;
      newEnv = env;
      body = this.run(ast.body, newEnv);
      catches = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.catches;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          _results.push(this._catch(c, env, block));
        }
        return _results;
      }).call(this);
      fin = ast["finally"] ? this._finally(ast["finally"], env, block) : null;
      return block.push(AST["try"](body, catches, fin));
    };

    AnfRegistry.prototype._import = function(ast, env, block) {
      var binding, defines;
      defines = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.bindings;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          binding = _ref[_i];
          _results.push(this.run(ast.define(binding), env, block));
        }
        return _results;
      }).call(this);
      return block.push(AST.unit());
    };

    AnfRegistry.prototype._export = function(ast, env, block) {
      var binding, bindings, spec;
      bindings = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.bindings;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          binding = _ref[_i];
          spec = this.run(binding.spec, env, block);
          _results.push(AST.binding(spec, binding.as));
        }
        return _results;
      }).call(this);
      return block.push(AST["export"](bindings));
    };

    AnfRegistry.prototype._let = function(ast, env, block) {
      var body, define, defines, exp, newEnv, res, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
      newEnv = env;
      defines = [];
      _ref = ast.defines;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        define = _ref[_i];
        res = this.run(define, newEnv);
        if (res.type() === 'block') {
          _ref1 = res.items;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            exp = _ref1[_j];
            block.push(exp);
          }
        } else {
          block.push(res);
        }
      }
      body = this.run(ast.body, newEnv);
      if (body.type() === 'block') {
        _ref2 = body.items;
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          exp = _ref2[_k];
          _results.push(block.push(exp));
        }
        return _results;
      } else {
        return block.push(body);
      }
    };

    AnfRegistry.prototype._toplevel = function(ast, env, block) {
      var body;
      body = this.runInner(ast.body, env, block);
      return ast.clone(AST["return"](body));
    };

    AnfRegistry.prototype._module = function(ast, env, block) {
      var body;
      body = this.runInner(ast.body, env, block);
      return ast.clone(AST["return"](body));
    };

    return AnfRegistry;

  })();

  module.exports = AnfRegistry;

}).call(this);
