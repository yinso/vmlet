// Generated by CoffeeScript 1.4.0
(function() {
  var AST, CLONE, Environment, HashMap, TR, filterDefines, getDefines, importDefines, isTail, normalize, transform, _combineProcs, _extendProcParams, _findTailCallProcs, _transformTailcall;

  AST = require('./ast');

  isTail = require('./istail');

  TR = require('./trace');

  HashMap = require('./hashmap');

  CLONE = require('./clone');

  Environment = (function() {

    function Environment() {
      this.inner = new HashMap();
    }

    Environment.prototype.setProc = function(proc) {
      return this.set(proc.name, proc);
    };

    Environment.prototype.setRef = function(ref) {
      return this.set(ref, ref.value);
    };

    Environment.prototype.setDefine = function(def) {
      return this.set(def.name, def.value);
    };

    Environment.prototype.has = function(ref) {
      return this.inner.has(ref);
    };

    Environment.prototype.set = function(key, val) {
      this.inner.set(key, val);
      return this;
    };

    Environment.prototype["delete"] = function(ref) {
      return this.inner["delete"](ref);
    };

    Environment.prototype.keys = function() {
      return this.inner.keys();
    };

    Environment.prototype.values = function() {
      return this.inner.values();
    };

    return Environment;

  })();

  normalize = function(ast) {
    var def, defines, env, i, results, _i, _len;
    env = new Environment();
    defines = getDefines(ast, env);
    results = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = defines.length; _i < _len; _i++) {
        def = defines[_i];
        _results.push(transform(def.value));
      }
      return _results;
    })();
    for (i = _i = 0, _len = defines.length; _i < _len; i = ++_i) {
      def = defines[i];
      def.value = results[i];
    }
    return results;
  };

  getDefines = function(ast, env) {
    var i, item, items, results, _i, _len;
    items = (function() {
      switch (ast.body.type()) {
        case 'block':
          return ast.body.items;
        default:
          return [ast.body];
      }
    })();
    results = [];
    for (i = _i = 0, _len = items.length; _i < _len; i = ++_i) {
      item = items[i];
      switch (item.type()) {
        case 'define':
        case 'local':
          if (item.value.type() === 'procedure') {
            env.setDefine(item);
            results.push(item);
          }
      }
    }
    return results;
  };

  transform = function(ast, env) {
    var proc, procs, res;
    if (env == null) {
      env = new Environment();
    }
    res = _findTailCallProcs(ast, env);
    if (!res) {
      return ast;
    }
    procs = env.values();
    proc = procs.length > 0 ? _combineProcs(res, procs) : res;
    return _transformTailcall(proc);
  };

  _combineProcs = function(ast, procs) {
    var body, locals, proc, _i, _len;
    locals = [];
    for (_i = 0, _len = procs.length; _i < _len; _i++) {
      proc = procs[_i];
      if (proc !== ast) {
        locals.push(AST.local(proc.name, proc));
      }
    }
    body = AST.block(locals.concat(ast.body.type() === 'block' ? ast.body.items : [ast.body]));
    return CLONE.transform(AST.procedure(ast.name, ast.params, body));
  };

  _extendProcParams = function(ast) {
    var i, locals, newParams, param;
    newParams = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.params;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        param = _ref[_i];
        _results.push(param.clone(AST.symbol(param.name.value + "$")));
      }
      return _results;
    })();
    locals = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.params;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        param = _ref[i];
        _results.push(AST.local(param.name, newParams[i].ref()));
      }
      return _results;
    })();
    return AST.procedure(ast.name, newParams, AST.block(locals.concat(ast.body.type() === 'block' ? ast.body.items : [ast.body])));
  };

  _transformTailcall = function(ast) {
    return ast;
  };

  _findTailCallProcs = function(ast, env, stack) {
    var defines, filtered, proc, refs, _i, _len;
    if (stack == null) {
      stack = [ast];
    }
    refs = isTail.transform(ast);
    if (refs.length > 0) {
      defines = getDefines(ast, env);
      filtered = filterDefines(ast, refs, env);
      for (_i = 0, _len = filtered.length; _i < _len; _i++) {
        proc = filtered[_i];
        if (stack.indexOf(proc) === -1) {
          _findTailCallProcs(proc, env, stack.concat(filtered));
        }
      }
      return ast;
    } else {
      return null;
    }
  };

  filterDefines = function(ast, refs, env) {
    var ref, _i, _len;
    for (_i = 0, _len = refs.length; _i < _len; _i++) {
      ref = refs[_i];
      if (env.has(ref)) {
        env["delete"](ref);
      } else {
        env.setRef(ref);
      }
    }
    return env.values();
  };

  importDefines = function(ast, filtered) {
    var body, defines, proc;
    defines = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = filtered.length; _i < _len; _i++) {
        proc = filtered[_i];
        _results.push(proc.local());
      }
      return _results;
    })();
    body = ast.body.type() === 'block' ? AST.block(defines.concat(ast.body.items)) : AST.block(defines.concat(ast.body));
    return AST.procedure(ast.name, ast.params, body);
  };

  module.exports = {
    normalize: normalize
  };

}).call(this);
