// Generated by CoffeeScript 1.4.0
(function() {
  var ANF, AST, errorlet, get, loglet, override, propagate, propagateBlock, propagateCatch, propagateDefine, propagateIf, propagateLocal, propagateProcedure, propagateScalar, propagateTask, propagateTry, propagateUnit, register, types, util, _propagate, _propagateInner, _propagateLocalItem;

  loglet = require('loglet');

  errorlet = require('errorlet');

  AST = require('./ast');

  ANF = require('./anf');

  util = require('./util');

  types = {};

  register = function(ast, cps) {
    if (types.hasOwnProperty(ast.type)) {
      throw errorlet.create({
        error: 'RETURN.duplicate_ast_type',
        type: ast.type
      });
    } else {
      return types[ast.type] = cps;
    }
  };

  get = function(ast) {
    if (types.hasOwnProperty(ast.type())) {
      return types[ast.type()];
    } else {
      throw errorlet.create({
        error: 'RETURN.unsupported_as_type',
        type: ast.type()
      });
    }
  };

  override = function(ast, cps) {
    return types[ast.type] = cps;
  };

  /*
  return is a bit difficult to get working. Because it's somewhat context dependent.
  
  return ought to be simple, except where it gets worked together with a few complex constructs.
  
  when we get to return, we have done ASN transformation - it means we should be working from a block at the top level.
  
  ASN has the following format. 
  
  (block 
    (tempVar exp)
    ...
    lastResult)
  
  We will need to make sure that the return gets
  */


  propagate = function(ast) {
    loglet.log('RETURN.propagate', ast);
    return _propagate(ast, 0);
  };

  _propagate = function(ast, level) {
    var propagator;
    propagator = get(ast);
    return propagator(ast, level);
  };

  _propagateInner = function(ast) {
    var val;
    switch (ast.type()) {
      case 'local':
        val = _propagateLocalItem(ast.normalized());
        return ast.clone(val);
      default:
        return ast;
    }
  };

  _propagateLocalItem = function(ast, level) {
    var res;
    switch (ast.type()) {
      case 'procedure':
      case 'task':
        res = _propagate(ast);
        if (res.type() === 'return') {
          return res.value;
        } else {
          return res;
        }
        break;
      default:
        return ast;
    }
  };

  propagateUnit = function(ast, level) {
    return ast;
  };

  register(AST.get('return'), propagateUnit);

  register(AST.get('throw'), propagateUnit);

  propagateScalar = function(ast, level) {
    return AST.make('return', ast);
  };

  register(AST.get('number'), propagateScalar);

  register(AST.get('string'), propagateScalar);

  register(AST.get('bool'), propagateScalar);

  register(AST.get('null'), propagateScalar);

  register(AST.get('symbol'), propagateScalar);

  register(AST.get('binary'), propagateScalar);

  register(AST.get('funcall'), propagateScalar);

  register(AST.get('member'), propagateScalar);

  register(AST.get('array'), propagateScalar);

  register(AST.get('object'), propagateScalar);

  register(AST.get('ref'), propagateScalar);

  register(AST.get('proxyval'), propagateScalar);

  register(AST.get('taskcall'), propagateScalar);

  propagateProcedure = function(ast, level) {
    console.log('RETURN.procedure', ast);
    return AST.make('return', AST.make('procedure', ast.name, ast.params, _propagate(ast.body, level + 1)));
  };

  register(AST.get('procedure'), propagateProcedure);

  propagateTask = function(ast, level) {
    return AST.make('return', AST.make('task', ast.name, ast.params, _propagate(ast.body, level + 1)));
  };

  register(AST.get('task'), propagateTask);

  propagateLocal = function(ast, level) {
    return _propagate(ast.normalized(), level + 1);
  };

  register(AST.get('local'), propagateLocal);

  propagateDefine = function(ast, level) {
    var body;
    body = _propagate(ast.value, level + 1);
    if (body.isa('return')) {
      return AST.make('define', ast.name, body.value);
    } else {
      return AST.make('define', ast.name, body);
    }
  };

  register(AST.get('define'), propagateDefine);

  propagateIf = function(ast, level) {
    var elseE, thenE;
    thenE = _propagate(ast.then, level);
    elseE = _propagate(ast["else"], level);
    return AST.make('if', ast.cond, thenE, elseE);
  };

  register(AST.get('if'), propagateIf);

  propagateBlock = function(ast, level) {
    var i, item, items;
    items = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.items;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        item = _ref[i];
        if (i < ast.items.length - 1) {
          _results.push(_propagateInner(item, level + 1));
        } else {
          _results.push(_propagate(item, level + 1));
        }
      }
      return _results;
    })();
    if (items[items.length - 1].type() === 'define') {
      items.push(AST.make('return', AST.make('proxyval', '_rt.unit')));
    }
    return AST.make('block', items);
  };

  register(AST.get('block'), propagateBlock);

  propagateCatch = function(ast, level) {
    var body;
    body = _propagate(ast.body, level + 1);
    return AST.make('catch', ast.param, body);
  };

  register(AST.get('catch'), propagateCatch);

  propagateTry = function(ast, level) {
    var body, c, catches;
    body = _propagate(ast.body, level + 1);
    catches = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.catches;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(_propagate(c, level + 1));
      }
      return _results;
    })();
    return AST.make('try', body, catches, ast["finally"]);
  };

  register(AST.get('try'), propagateTry);

  module.exports = {
    register: register,
    get: get,
    override: override,
    transform: propagate
  };

}).call(this);
