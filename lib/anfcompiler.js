// Generated by CoffeeScript 1.4.0
(function() {
  var ANF, AST, LineBuffer, compile, compileArray, compileBinary, compileDefine, compileFuncall, compileIf, compileMember, compileObject, compileParam, compileProcedure, compileProxyVal, compileRef, compileReturn, compileScalar, compileSymbol, compileTempVar, compileThrow, errorlet, get, loglet, override, register, types, _compile, _compileANF, _compileOne;

  loglet = require('loglet');

  errorlet = require('errorlet');

  AST = require('./ast');

  ANF = require('./anf');

  LineBuffer = require('./linebuffer');

  types = {};

  register = function(ast, compiler) {
    if (types.hasOwnProperty(ast.type)) {
      throw errorlet.create({
        error: 'compiler:duplicate_compiler_type',
        type: ast.type
      });
    } else {
      return types[ast.type] = compiler;
    }
  };

  get = function(ast) {
    if (types.hasOwnProperty(ast.constructor.type)) {
      return types[ast.constructor.type];
    } else {
      throw errorlet.create({
        error: 'compiler:unsupported_ast_type',
        type: ast.constructor.type
      });
    }
  };

  override = function(ast, compiler) {
    return types[ast.type] = compiler;
  };

  compile = function(anf) {
    var res;
    res = _compile(anf);
    return "(function (_done) {\n  try {\n    " + res + "\n  } catch (e) {\n    return _done(e);\n  }\n})(_done)";
  };

  _compile = function(anf, buffer, level) {
    if (buffer == null) {
      buffer = new LineBuffer();
    }
    if (level == null) {
      level = 0;
    }
    if (ANF.isANF(anf)) {
      _compileANF(anf, buffer, level);
    } else {
      _compileOne(anf, buffer, level);
    }
    return buffer.toString();
  };

  _compileANF = function(anf, buffer, level) {
    var i, item, _i, _len, _ref, _results;
    _ref = anf.items;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      item = _ref[i];
      _results.push(_compile(anf.items[i], buffer, level));
    }
    return _results;
  };

  _compileOne = function(ast, buffer, level) {
    var compiler;
    compiler = get(ast);
    return compiler(ast, buffer, level);
  };

  compileScalar = function(ast, buffer, level) {
    return buffer.push(JSON.stringify(ast.val));
  };

  register(AST.get('number'), compileScalar);

  register(AST.get('bool'), compileScalar);

  register(AST.get('null'), compileScalar);

  register(AST.get('string'), compileScalar);

  compileSymbol = function(ast, buffer, level) {
    return buffer.push(ast.val);
  };

  register(AST.get('symbol'), compileSymbol);

  compileRef = function(ast, buffer, level) {
    return buffer.push(ast.val);
  };

  register(AST.get('ref'), compileRef);

  compileBinary = function(ast, buffer, level) {
    var lhs, rhs;
    lhs = _compile(ast.lhs, new LineBuffer(), level);
    rhs = _compile(ast.rhs, new LineBuffer(), level);
    return buffer.push("" + lhs + " " + ast.op + " " + rhs);
  };

  register(AST.get('binary'), compileBinary);

  compileDefine = function(ast, buffer, level) {
    var value;
    value = _compile(ast.val, new LineBuffer(), level);
    return buffer.push("_rt.define(" + (JSON.stringify(ast.name)) + ", " + value + ");");
  };

  register(AST.get('define'), compileDefine);

  compileTempVar = function(ast, buffer, level) {
    var value;
    value = _compile(ast.val, new LineBuffer(), level);
    return buffer.push("var " + ast.name + " = " + value + ";");
  };

  register(AST.get('tempvar'), compileTempVar);

  compileParam = function(ast, buffer, level) {
    return buffer.push(ast.name);
  };

  register(AST.get('param'), compileParam);

  compileProcedure = function(ast, buffer, level) {
    var body, param, params;
    loglet.log('compileProcedure', ast, level);
    body = _compile(ast.body, new LineBuffer(), level + 1);
    params = ((function() {
      var _i, _len, _ref, _results;
      _ref = ast.params;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        param = _ref[_i];
        _results.push(_compile(param));
      }
      return _results;
    })()).join(', ');
    buffer.push("function ");
    if (ast.name) {
      buffer.push(ast.name);
    }
    buffer.push("(" + params + ") { ");
    return buffer.push("" + body + " }");
  };

  register(AST.get('procedure'), compileProcedure);

  compileFuncall = function(ast, buffer, level) {
    var arg, args;
    _compileOne(ast.funcall, buffer, level);
    args = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.args;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        _results.push(_compile(arg, new LineBuffer(), level));
      }
      return _results;
    })();
    return buffer.push("(" + (args.join(', ')) + ")");
  };

  register(AST.get('funcall'), compileFuncall);

  compileMember = function(ast, buffer, level) {
    var key;
    _compileOne(ast.head, buffer, level);
    key = _compile(ast.key, new LineBuffer(), level);
    if (AST.isa(ast.key, 'symbol')) {
      return buffer.push("." + key);
    } else {
      return buffer.push("[" + key + "]");
    }
  };

  register(AST.get('member'), compileMember);

  compileObject = function(ast, buffer, level) {
    var i, key, val, _i, _len, _ref, _ref1;
    buffer.push('{');
    _ref = ast.val;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      _ref1 = _ref[i], key = _ref1[0], val = _ref1[1];
      buffer.push(JSON.stringify(key));
      buffer.push(': ');
      _compileOne(val, buffer, level);
      if (i < ast.val.length - 1) {
        buffer.push(', ');
      }
    }
    return buffer.push('}');
  };

  register(AST.get('object'), compileObject);

  compileArray = function(ast, buffer, level) {
    var i, item, _i, _len, _ref;
    buffer.push('[');
    _ref = ast.val;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      item = _ref[i];
      _compileOne(item, buffer, level);
      if (i < ast.val.length - 1) {
        buffer.push(', ');
      }
    }
    return buffer.push(']');
  };

  register(AST.get('array'), compileObject);

  compileProxyVal = function(ast, buffer, level) {
    buffer.push("_rt.get(");
    buffer.push(JSON.stringify(ast.name));
    return buffer.push(")");
  };

  register(AST.get('proxyval'), compileProxyVal);

  compileReturn = function(ast, buffer, level) {
    var arg, val, _i, _len, _ref;
    val = ast.val;
    loglet.log('compileReturn', ast, level, val.type());
    if (val.type() === 'funcall') {
      if (level > 0) {
        buffer.push("return _rt.tail(");
      } else {
        buffer.push("return _rt.tco(");
      }
      _compile(val.funcall, buffer, level + 1);
      _ref = val.args;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        buffer.push(", ");
        _compile(arg, buffer, level + 1);
      }
    } else if (level > 0) {
      buffer.push("return (");
      _compile(val, buffer, level + 1);
    } else {
      buffer.push("return _done(null, ");
      _compile(val, buffer, level + 1);
    }
    if (level === 0 && val.type() === 'funcall') {
      buffer.push(", _done);");
    } else {
      buffer.push(");");
    }
    return buffer.newline();
  };

  register(AST.get('return'), compileReturn);

  compileThrow = function(ast, buffer, level) {
    buffer.push("throw ");
    _compile(ast.val, buffer);
    buffer.push(";");
    return buffer.newline();
  };

  register(AST.get('throw'), compileThrow);

  compileIf = function(ast, buffer, level) {
    var condE, elseE, thenE;
    condE = _compile(ast["if"], new LineBuffer(), level);
    thenE = _compile(ast.then, new LineBuffer(), level);
    elseE = _compile(ast["else"], new LineBuffer(), level);
    buffer.write("if (" + condE + ") {");
    buffer.newline();
    buffer.indent();
    buffer.write(thenE);
    buffer.outdent();
    buffer.write("} else {");
    buffer.indent();
    buffer.write(elseE);
    buffer.outdent();
    return buffer.write("}");
  };

  register(AST.get('if'), compileIf);

  module.exports = {
    compile: compile,
    get: get,
    register: register,
    override: override
  };

  /*
  # tail recursive version
  (function (n) { (function helper(n, cur, next) { if n <= 0 cur else helper(n - 1, next, cur + next) })(n, 0, 1) })(5)
  define fib = function(n) { define helper = function helper(n, cur, next) { if n <= 0 cur else helper(n - 1, next, cur + next)} helper(n, 0, 1) }
  */


}).call(this);
