// Generated by CoffeeScript 1.4.0
(function() {
  var ANF, AST, LineBuffer, compile, compileArray, compileBinary, compileCatch, compileDefine, compileFinally, compileFuncall, compileIf, compileMember, compileNull, compileObject, compileParam, compileProcedure, compileProxyVal, compileRef, compileReturn, compileScalar, compileSymbol, compileTempVar, compileThrow, compileTry, errorlet, get, loglet, override, register, types, _compile, _compileANF, _compileOne;

  loglet = require('loglet');

  errorlet = require('errorlet');

  AST = require('./ast');

  ANF = require('./anf');

  LineBuffer = require('./linebuffer');

  types = {};

  register = function(ast, compiler) {
    if (types.hasOwnProperty(ast.type)) {
      throw errorlet.create({
        error: 'compiler:duplicate_compiler_type',
        type: ast.type
      });
    } else {
      return types[ast.type] = compiler;
    }
  };

  get = function(ast) {
    if (types.hasOwnProperty(ast.constructor.type)) {
      return types[ast.constructor.type];
    } else {
      throw errorlet.create({
        error: 'compiler:unsupported_ast_type',
        type: ast.constructor.type
      });
    }
  };

  override = function(ast, compiler) {
    return types[ast.type] = compiler;
  };

  compile = function(anf) {
    var res;
    res = _compile(anf);
    return "(function () {\n  return " + res + ";\n})()";
  };

  _compile = function(anf, buffer, level) {
    if (buffer == null) {
      buffer = new LineBuffer();
    }
    if (level == null) {
      level = 0;
    }
    if (ANF.isANF(anf)) {
      _compileANF(anf, buffer, level);
    } else {
      _compileOne(anf, buffer, level);
    }
    return buffer.toString();
  };

  _compileANF = function(anf, buffer, level) {
    var i, item, _i, _len, _ref, _results;
    _ref = anf.items;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      item = _ref[i];
      _compile(anf.items[i], buffer, level);
      buffer.push("; ");
      _results.push(buffer.newline());
    }
    return _results;
  };

  register(AST.get('anf'), _compileANF);

  register(AST.get('block'), _compileANF);

  _compileOne = function(ast, buffer, level) {
    var compiler;
    loglet.log('_complieOne', ast, level);
    compiler = get(ast);
    return compiler(ast, buffer, level);
  };

  compileScalar = function(ast, buffer, level) {
    return buffer.push(JSON.stringify(ast.val));
  };

  register(AST.get('number'), compileScalar);

  register(AST.get('bool'), compileScalar);

  register(AST.get('string'), compileScalar);

  compileNull = function(ast, buffer, level) {
    return buffer.push("null");
  };

  register(AST.get('null'), compileNull);

  compileSymbol = function(ast, buffer, level) {
    return buffer.push(ast.val);
  };

  register(AST.get('symbol'), compileSymbol);

  compileRef = function(ast, buffer, level) {
    return buffer.push(ast.val);
  };

  register(AST.get('ref'), compileRef);

  compileBinary = function(ast, buffer, level) {
    var lhs, rhs;
    lhs = _compile(ast.lhs, new LineBuffer(), level);
    rhs = _compile(ast.rhs, new LineBuffer(), level);
    return buffer.push("" + lhs + " " + ast.op + " " + rhs);
  };

  register(AST.get('binary'), compileBinary);

  compileDefine = function(ast, buffer, level) {
    var value;
    value = _compile(ast.val, new LineBuffer(), level);
    return buffer.writeLine("_rt.define(" + (JSON.stringify(ast.name)) + ", " + value + ");");
  };

  register(AST.get('define'), compileDefine);

  compileTempVar = function(ast, buffer, level) {
    var value;
    value = _compile(ast.val, new LineBuffer(), level);
    return buffer.writeLine("var " + ast.name + " = " + value + ";");
  };

  register(AST.get('tempvar'), compileTempVar);

  compileParam = function(ast, buffer, level) {
    return buffer.push(ast.name);
  };

  register(AST.get('param'), compileParam);

  compileProcedure = function(ast, buffer, level) {
    var body, param, params;
    loglet.log('compileProcedure', ast, level);
    body = _compile(ast.body, new LineBuffer(), level + 1);
    params = ((function() {
      var _i, _len, _ref, _results;
      _ref = ast.params;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        param = _ref[_i];
        _results.push(_compile(param));
      }
      return _results;
    })()).join(', ');
    buffer.push("function ");
    if (ast.name) {
      buffer.push(ast.name);
    }
    buffer.push("(" + params + ") { ");
    return buffer.push("" + body + " }");
  };

  register(AST.get('procedure'), compileProcedure);

  compileFuncall = function(ast, buffer, level) {
    var arg, args;
    _compileOne(ast.funcall, buffer, level);
    args = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.args;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        _results.push(_compile(arg, new LineBuffer(), level));
      }
      return _results;
    })();
    return buffer.push("(" + (args.join(', ')) + ")");
  };

  register(AST.get('funcall'), compileFuncall);

  compileMember = function(ast, buffer, level) {
    var key;
    buffer.push("_rt.member(");
    _compileOne(ast.head, buffer, level);
    buffer.push(", ");
    if (ast.key.type() === 'symbol') {
      buffer.push(JSON.stringify(ast.key.val));
    } else {
      key = _compile(ast.key, new LineBuffer(), level);
      buffer.push(key);
    }
    return buffer.push(")");
  };

  register(AST.get('member'), compileMember);

  compileObject = function(ast, buffer, level) {
    var i, key, val, _i, _len, _ref, _ref1;
    buffer.push('{');
    _ref = ast.val;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      _ref1 = _ref[i], key = _ref1[0], val = _ref1[1];
      buffer.push(JSON.stringify(key));
      buffer.push(': ');
      _compileOne(val, buffer, level);
      if (i < ast.val.length - 1) {
        buffer.push(', ');
      }
    }
    return buffer.push('}');
  };

  register(AST.get('object'), compileObject);

  compileArray = function(ast, buffer, level) {
    var i, item, _i, _len, _ref;
    buffer.push('[');
    _ref = ast.val;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      item = _ref[i];
      _compileOne(item, buffer, level);
      if (i < ast.val.length - 1) {
        buffer.push(', ');
      }
    }
    return buffer.push(']');
  };

  register(AST.get('array'), compileObject);

  compileProxyVal = function(ast, buffer, level) {
    return buffer.push(ast.compile());
  };

  register(AST.get('proxyval'), compileProxyVal);

  compileReturn = function(ast, buffer, level) {
    var type, val;
    val = ast.val;
    type = val.type();
    buffer.push("return ");
    _compile(val, buffer, level);
    return buffer.push(";");
  };

  register(AST.get('return'), compileReturn);

  compileThrow = function(ast, buffer, level) {
    buffer.push("throw ");
    _compile(ast.val, buffer);
    return buffer.writeLine(";");
  };

  register(AST.get('throw'), compileThrow);

  compileTry = function(ast, buffer, level) {
    var c, _i, _len, _ref;
    buffer.push("try { ");
    _compile(ast.body, buffer, level + 1);
    buffer.push(" } ");
    _ref = ast.catches;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      _compile(c, buffer, level);
    }
    return _compile(ast["finally"], buffer, level);
  };

  register(AST.get('try'), compileTry);

  compileCatch = function(ast, buffer, level) {
    buffer.push("catch (");
    _compile(ast.param, buffer, level);
    buffer.push(") { ");
    _compile(ast.body, buffer, level + 1);
    return buffer.push("} ");
  };

  register(AST.get('catch'), compileCatch);

  compileFinally = function(ast, buffer, level) {
    buffer.push("finally { ");
    _compile(ast.body, buffer, level + 1);
    return buffer.push("} ");
  };

  register(AST.get('finally'), compileFinally);

  compileIf = function(ast, buffer, level) {
    var condE, elseE, thenE;
    loglet.log('--compileIf', ast);
    condE = _compile(ast["if"], new LineBuffer(), level);
    thenE = _compile(ast.then, new LineBuffer(), level);
    elseE = _compile(ast["else"], new LineBuffer(), level);
    buffer.write("if (" + condE + ") {");
    buffer.newline();
    buffer.indent();
    buffer.write(thenE);
    buffer.outdent();
    buffer.write("} else {");
    buffer.indent();
    buffer.write(elseE);
    buffer.outdent();
    return buffer.write("}");
  };

  register(AST.get('if'), compileIf);

  module.exports = {
    compile: compile,
    get: get,
    register: register,
    override: override
  };

  /*
  # tail recursive version
  (function (n) { (function helper(n, cur, next) { if n <= 0 cur else helper(n - 1, next, cur + next) })(n, 0, 1) })(5)
  define fib = function(n) { define helper = function helper(n, cur, next) { if n <= 0 cur else helper(n - 1, next, cur + next)} helper(n, 0, 1) }
  */


}).call(this);
