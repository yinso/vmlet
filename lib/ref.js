// Generated by CoffeeScript 1.4.0
(function() {
  var AST, Ref, TR;

  AST = require('./ast');

  TR = require('./trace');

  Ref = (function() {

    function Ref() {}

    Ref.transform = function(ast) {
      if (!this.reg) {
        this.reg = new this();
      }
      return this.reg.transform(ast);
    };

    Ref.prototype.transform = function(ast) {
      var refs;
      refs = [];
      this.run(ast, refs);
      return refs;
    };

    Ref.prototype.run = function(ast, refs) {
      var type;
      type = "_" + (ast.type());
      if (this[type]) {
        return this[type](ast, refs);
      } else {
        throw new Error("Ref.unknown_ast: " + (ast.type()));
      }
    };

    Ref.prototype._number = function(ast, refs) {};

    Ref.prototype._string = function(ast, refs) {};

    Ref.prototype._bool = function(ast, refs) {};

    Ref.prototype._null = function(ast, refs) {};

    Ref.prototype._unit = function(ast, refs) {};

    Ref.prototype._symbol = function(ast, refs) {};

    Ref.prototype._continue = function(ast, refs) {};

    Ref.prototype._break = function(ast, refs) {};

    Ref.prototype._ref = function(ast, refs) {
      if (refs.indexOf(ast) === -1) {
        return refs.push(ast);
      }
    };

    Ref.prototype._binary = function(ast, refs) {
      this.run(ast.lhs, refs);
      return this.run(ast.rhs, refs);
    };

    Ref.prototype._member = function(ast, refs) {
      return this.run(ast.head, refs);
    };

    Ref.prototype._if = function(ast, refs) {
      this.run(ast.cond, refs);
      this.run(ast.then, refs);
      return this.run(ast["else"], refs);
    };

    Ref.prototype._define = function(ast, refs) {
      if (ast.value) {
        return this.run(ast.value, refs);
      }
    };

    Ref.prototype._local = function(ast, refs) {
      if (ast.value) {
        return this.run(ast.value, refs);
      }
    };

    Ref.prototype._assign = function(ast, refs) {
      if (ast.value) {
        return this.run(ast.value, refs);
      }
    };

    Ref.prototype._procedure = function(ast, refs) {
      return this.run(ast.body, refs);
    };

    Ref.prototype._task = function(ast, refs) {
      return this.run(ast.body, refs);
    };

    Ref.prototype._module = function(ast, refs) {
      return this.run(ast.body, refs);
    };

    Ref.prototype._toplevel = function(ast, refs) {
      return this.run(ast.body, refs);
    };

    Ref.prototype._funcall = function(ast, refs) {
      var arg, _i, _len, _ref, _results;
      this.run(ast.funcall, refs);
      _ref = ast.args;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        _results.push(this.run(arg, refs));
      }
      return _results;
    };

    Ref.prototype._taskcall = function(ast, refs) {
      var arg, _i, _len, _ref, _results;
      this.run(ast.funcall, refs);
      _ref = ast.args;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        _results.push(this.run(arg, refs));
      }
      return _results;
    };

    Ref.prototype._block = function(ast, refs) {
      var i, item, _i, _len, _ref, _results;
      _ref = ast.items;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        item = _ref[i];
        _results.push(this.run(item, refs));
      }
      return _results;
    };

    Ref.prototype._catch = function(ast, refs) {
      return this.run(ast.body, refs);
    };

    Ref.prototype._try = function(ast, refs) {
      var c, _i, _len, _ref;
      this.run(ast.body, refs);
      _ref = ast.catches;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        this.run(c, refs);
      }
      if (ast["finally"]) {
        return this.run(ast["finally"], refs);
      }
    };

    Ref.prototype._return = function(ast, refs) {
      return this.run(ast.value, refs);
    };

    Ref.prototype._while = function(ast, refs) {
      this.run(ast.cond, refs);
      return this.run(ast.block, refs);
    };

    Ref.prototype._switch = function(ast, refs) {
      var c, _i, _len, _ref, _results;
      this.run(ast.cond, refs);
      _ref = ast.cases;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(this.run(c, refs));
      }
      return _results;
    };

    Ref.prototype._case = function(ast, refs) {
      this.run(ast.cond, refs);
      return this.run(ast.exp, refs);
    };

    Ref.prototype._defaultCase = function(ast, refs) {
      return this.run(ast.exp, refs);
    };

    return Ref;

  })();

  module.exports = Ref;

  /*
  #
  _types = {}
  
  register = (ast, trans) -> 
    if _types.hasOwnProperty(ast.type)
      throw new Error("ref.duplicate_type: #{ast.type}")
    _types[ast.type] = trans 
  
  get = (ast) -> 
    if _types.hasOwnProperty(ast.type())
      _types[ast.type()]
    else
      throw new Error("ref.invalid_type: #{ast.type()}")
  
  transform = (ast) -> 
    refs = []
    _trans ast , refs
    refs 
  
  _trans = (ast, refs) -> 
    trans = get ast
    trans ast, refs 
  
  _scalar = (ast, refs) -> 
  
  register AST.get('number'), _scalar
  register AST.get('bool'), _scalar
  register AST.get('string'), _scalar
  register AST.get('null'), _scalar
  register AST.get('unit'), _scalar
  register AST.get('symbol'), _scalar
  register AST.get('continue'), _scalar
  register AST.get('break'), _scalar
  
  _ref = (ast, refs) -> 
    if refs.indexOf(ast) == -1
      refs.push ast 
  
  register AST.get('ref'), _ref 
  
  _binary = (ast, refs) -> 
    _trans ast.lhs, refs
    _trans ast.rhs, refs
  
  register AST.get('binary'), _binary
  
  _member = (ast, refs) -> 
    _trans ast.head, refs
  
  register AST.get('member'), _member
  
  _if = (ast, refs) -> 
    _trans ast.cond, refs 
    _trans ast.then, refs 
    _trans ast.else, refs
  
  register AST.get('if'), _if 
  
  _define = (ast, refs) -> 
    if ast.value 
      _trans ast.value, refs
    
  register AST.get('define'), _define
  register AST.get('local'), _define
  register AST.get('assign'), _define
  
  _proc = (ast, refs) -> 
    _trans ast.body, refs 
  
  register AST.get('procedure'), _proc
  register AST.get('task'), _proc
  register AST.get('module'), _proc
  register AST.get('toplevel'), _proc
  register AST.get('catch'), _proc
  
  _funcall = (ast, refs) -> 
    _trans ast.funcall, refs 
    for arg in ast.args
      _trans arg, refs 
  
  register AST.get('funcall'), _funcall
  register AST.get('taskcall'), _funcall
  
  _block = (ast, refs) -> 
    for item, i in ast.items 
      _trans item, refs 
  
  register AST.get('block'), _block
  
  _try = (ast, refs) -> 
    _trans ast.body, refs 
    for c in ast.catches
      _trans c, refs 
    if ast.finally
      _trans ast.finally, refs
  
  register AST.get('try'), _try 
  
  _return = (ast, refs) -> 
    _trans ast.value, refs
  
  register AST.get('return'), _return 
  
  _while = (ast, refs) -> 
    _trans ast.cond, refs 
    _trans ast.block, refs
  
  register AST.get('while'), _while 
  
  _switch = (ast, refs) -> 
    _trans ast.cond, refs 
    for c in ast.cases 
      _trans c, refs
  
  register AST.get('switch'), _switch
  
  _case = (ast, refs) -> 
    _trans ast.cond, refs 
    _trans ast.exp, refs 
  
  register AST.get('case'), _case
  
  _defaultCase = (ast, refs) -> 
    _trans ast.exp, refs
  
  register AST.get('defaultCase'), _defaultCase
  
  module.exports = 
    transform: transform 
    register: register
  */


}).call(this);
