// Generated by CoffeeScript 1.4.0
(function() {
  var AST, TR, callbackParam, cbAST, combine, concat, cps, cpsAssign, cpsBlock, cpsCatch, cpsDefine, cpsIf, cpsLocal, cpsReturn, cpsScalar, cpsTask, cpsTaskcall, cpsThrow, cpsTopLevel, cpsTry, errorParam, errorlet, get, loglet, makeCallback, makeCpsDef, normalize, override, register, runtimeParam, types, util, _cpsOne, _makeErrorHandler;

  loglet = require('loglet');

  errorlet = require('errorlet');

  AST = require('./ast');

  util = require('./util');

  TR = require('./trace');

  /*
  There are basically two types we need to handle the CPS conversion for: TASK and TOPLEVEL.
  
  The idea is simple. We add an implicit callback parameter, as well as continuation call for both regular and error 
  conditions. 
  
  TOPLEVE { exp exp2 ... expLast } 
  => 
  function (_done) { 
    try {
      exp exp2 ... 
      return _done(null, expLast); // whatever expLast evaluates to.
    } catch (e) {
      return _done(e);
    }
  }
  
  TASK(arg, ...) {
    exp ... expLast
  }
  => 
  _rt.task(function (arg, ..., _done) {
    try {
      exp ... 
      return _done(null, expLast); 
    } catch (e) {
      return _done(e);
    }
  });
  */


  /*
  
  CPS occurs with a funcall being async.
  
  res = foo(a, b, c)
  bar...
  baz...
  ==> 
    
  return _rt.tail(foo, a, b, c, function (err, res) {
    if (err) {
      return _rt.tail(cb, err);
    } else {
      bar...
      baz...
    }
    })
  
  The above shows that "bar... baz..." is the continuation of the funcall foo(a, b,, c), and if CPS'd it gets
  translated into the else branch of the callback. Note that res is the result from the function itslef, and 
  we have previously no reference to err symbol (unless we happen to be within a try catch block as well)
  
  Note that we might have to also compile backwards, so we successively generate the intermediate functions.
    
  Also note that we might not necessarily know whether a function is sync/async (we should know if the function is 
    previously created, but we might not know about functions yet to be created, and some functions might be ambiguous)...
  
  In a way - the current design is still ambiguous...
    
  In an if expression, CPS can occur for COND. Since ANF already get the expression separated, it's trivial in this case
  for the CPS.
  
  return _rt.tail(cond, ..., function(err, res) {
    if (err) {
      return _rt.tail(cb, err);
    } else {
      // this part is the original if expression.
      if (res) {
        //... the original then block
      } else {
        // ... the original else block...
      }
    }
  })
  
  Ambiguous can be difficult... but the idea is that we have the if expression (outside of the cond expression) being
  named as a block with the appropriate closure (block will be treated as a function as well).
  
  if a() { b c } else { d e }
  
  a$1 = a()
  block_if = function () {
    if (a$1) {
      b c
    } else {
      d e
    }
  }
  block_if()
  
  it turns out that in order to deal with async in a transparent level - we will need to have the ability to TYPE
  the expression (this is so that we can infer whether or not a particular value will be async).
  
  That means until we can do so, we are stuck with one of the approaches...
  */


  types = {};

  register = function(ast, cps) {
    if (types.hasOwnProperty(ast.type)) {
      throw errorlet.create({
        error: 'CPS.duplicate_ast_type',
        type: ast.type
      });
    } else {
      return types[ast.type] = cps;
    }
  };

  get = function(ast) {
    if (types.hasOwnProperty(ast.type())) {
      return types[ast.type()];
    } else {
      throw errorlet.create({
        error: 'CPS.unsupported_as_type',
        type: ast
      });
    }
  };

  override = function(ast, cps) {
    return types[ast.type] = cps;
  };

  runtimeParam = AST.param(AST.runtimeID);

  callbackParam = AST.param(AST.symbol('_done'));

  errorParam = AST.param(AST.symbol('e'));

  cbAST = callbackParam.ref();

  cps = function(ast) {
    var res;
    res = (function() {
      switch (ast.type()) {
        case 'task':
          return cpsTask(ast);
        case 'toplevel':
        case 'module':
          return cpsTopLevel(ast);
        default:
          throw new Error("CPS:unsupported_toplevel_type: " + ast);
      }
    })();
    console.log('-------- Runtime.cpsed =>', ast);
    return res;
  };

  _cpsOne = function(item, contAST, cbAST) {
    var cpser;
    cpser = get(item);
    return cpser(item, contAST, cbAST);
  };

  cpsTopLevel = function(ast) {
    var body, params, task;
    body = normalize(ast.body);
    params = [ast.moduleParam];
    cbAST = ast.callbackParam.ref();
    task = cpsTask(AST.task(null, params, body), cbAST, cbAST);
    return ast.clone(task.body);
  };

  register(AST.get('toplevel'), cpsTopLevel);

  cpsTask = function(ast, contAST, cbAST) {
    var body, params;
    body = normalize(ast.body);
    params = [].concat(ast.params).concat(callbackParam);
    console.log('--cpTask', body);
    body = body.items[0].type() === 'try' ? _cpsOne(body, cbAST, cbAST) : AST["try"](_cpsOne(body, cbAST, cbAST), [AST["catch"](errorParam, AST.block([AST["return"](AST.funcall(cbAST, [errorParam.ref()]))]))], null);
    return AST.procedure(ast.name, params, AST.block([body]));
  };

  register(AST.get('task'), cpsTask);

  cpsBlock = function(anf, contAST, cbAST) {
    var i, _i, _ref;
    for (i = _i = _ref = anf.items.length - 1; _i >= 0; i = _i += -1) {
      contAST = _cpsOne(anf.items[i], contAST, cbAST);
    }
    return normalize(contAST);
  };

  register(AST.get('block'), cpsBlock);

  cpsTaskcall = function(ast, contAST, cbAST) {
    var args;
    args = [].concat(ast.args);
    console.log('--cpsTaskcall', ast, contAST, cbAST);
    if (contAST.type() === 'procedure') {
      args.push(contAST);
    } else {
      args.push(makeCallback(contAST, cbAST));
    }
    return AST["return"](AST.funcall(ast.funcall, args));
  };

  register(AST.get('taskcall'), cpsTaskcall);

  combine = function(ast, contAST) {
    if (!contAST) {
      return ast;
    } else if (contAST.type() === 'block') {
      return AST.block([ast].concat(contAST.items));
    } else {
      return AST.block([ast, contAST]);
    }
  };

  concat = function(ast1, ast2) {
    var is1anf, is2anf;
    is1anf = ast1.type() === 'block';
    is2anf = ast2.type() === 'block';
    if (is1anf) {
      return AST.block(ast1.items.concat(is2anf ? ast2.items : [ast2]));
    } else {
      return AST.block([ast1].concat(is2anf ? ast2.items : [ast2]));
    }
  };

  normalize = function(ast) {
    if (ast.type() === 'block') {
      return ast;
    } else {
      return AST.block([ast]);
    }
  };

  makeCallback = function(contAST, cbAST, resParam) {
    var err;
    if (resParam == null) {
      resParam = AST.param('res');
    }
    err = AST.symbol('err');
    console.log('--makeCallback', contAST, cbAST, resParam);
    if (contAST === cbAST) {
      return contAST;
    } else {
      return AST.procedure(void 0, [AST.param(err), resParam], AST.block([AST["if"](err, AST["return"](AST.funcall(cbAST, [err])), contAST)]));
    }
  };

  cpsLocal = function(ast, contAST, cbAST) {
    if (ast.isAsync()) {
      return _cpsOne(ast.value, makeCallback(contAST, cbAST, AST.param(ast.name)), cbAST);
    } else {
      return combine(ast, contAST);
    }
  };

  register(AST.get('local'), cpsLocal);

  cpsAssign = function(ast, contAST, cbAST) {
    var head;
    if (ast.isAsync()) {
      return _cpsOne(ast.value, makeCallback(contAST, cbAST, AST.param(ast.name)), cbAST);
    } else {
      head = AST.assign(ast.name, _cpsOne(ast.value, null, null));
      return combine(head, contAST);
    }
  };

  register(AST.get('assign'), cpsAssign);

  makeCpsDef = function(type) {
    return function(ast, contAST, cbAST) {
      var head, param;
      if (ast.isAsync()) {
        param = AST.param(ast.name.clone());
        contAST = combine(AST.define(ast.name, param.name), contAST);
        return _cpsOne(ast.value, makeCallback(contAST, cbAST, param), cbAST);
      } else {
        head = AST.make(type, ast.name, _cpsOne(ast.value, null, null));
        return combine(head, contAST);
      }
    };
  };

  cpsDefine = makeCpsDef('define');

  register(AST.get('define'), cpsDefine);

  cpsReturn = function(ast, contAST, cbAST) {
    var val;
    val = ast.value;
    if (val.type() === 'taskcall') {
      return cpsTaskcall(val, contAST, cbAST);
    } else {
      return AST["return"](AST.funcall(cbAST, [AST.make('null'), _cpsOne(val, null, null)]));
    }
  };

  register(AST.get('return'), cpsReturn);

  cpsIf = function(ast, contAST, cbAST) {
    return AST["if"](ast.cond, _cpsOne(ast.then, contAST, cbAST), _cpsOne(ast["else"], contAST, cbAST));
  };

  register(AST.get('if'), cpsIf);

  cpsScalar = function(ast, contAST, cbAST) {
    return combine(ast, contAST);
  };

  register(AST.get('number'), cpsScalar);

  register(AST.get('bool'), cpsScalar);

  register(AST.get('null'), cpsScalar);

  register(AST.get('symbol'), cpsScalar);

  register(AST.get('string'), cpsScalar);

  register(AST.get('binary'), cpsScalar);

  register(AST.get('member'), cpsScalar);

  register(AST.get('procedure'), cpsScalar);

  register(AST.get('ref'), cpsScalar);

  register(AST.get('proxyval'), cpsScalar);

  register(AST.get('var'), cpsScalar);

  register(AST.get('funcall'), cpsScalar);

  register(AST.get('array'), cpsScalar);

  register(AST.get('object'), cpsScalar);

  register(AST.get('unit'), cpsScalar);

  register(AST.get('import'), cpsScalar);

  register(AST.get('export'), cpsScalar);

  cpsThrow = function(ast, contAST, cbAST) {
    return AST["return"](AST.funcall(cbAST, [ast.value]));
  };

  register(AST.get('throw'), cpsThrow);

  _makeErrorHandler = function(catchExp, finallyExp, cbAST, name) {
    var body, catchBody, errorBody, okReturnExp, resParam;
    console.log('--cps.makeErrorHandler', catchExp != null ? catchExp.body : void 0, finallyExp != null ? finallyExp.body : void 0, cbAST);
    catchBody = _cpsOne(catchExp.body, cbAST, cbAST);
    resParam = AST.param(AST.symbol('res'));
    okReturnExp = AST["return"](AST.funcall(cbAST, [catchExp.param.name, resParam.name]));
    errorBody = finallyExp ? AST["try"](_cpsOne(finallyExp.body, catchBody, catchBody), [AST["catch"](catchExp.param, AST.block([okReturnExp]))]) : catchBody;
    body = AST.block([AST["if"](catchExp.param.name, errorBody, okReturnExp)]);
    return AST.local(name, AST.procedure(void 0, [catchExp.param, resParam], body));
  };

  cpsTry = function(ast, contAST, cbAST) {
    var bodyAST, catchExp, errorAST, name, tryBody;
    name = AST.symbol('__handleError', 1);
    console.log('--cpsTry', ast.catches[0], ast["finally"]);
    catchExp = ast.catches.length > 0 ? ast.catches[0] : AST["catch"](errorParam, AST.block([AST["throw"](errorParam.name)]));
    errorAST = _makeErrorHandler(catchExp, ast["finally"], cbAST, name);
    cbAST = name;
    bodyAST = _cpsOne(ast.body, contAST, cbAST);
    tryBody = combine(errorAST, bodyAST);
    return AST["try"](tryBody, [AST["catch"](errorParam, AST.block([AST["return"](AST.funcall(errorAST.name, [errorParam.name]))]))]);
  };

  register(AST.get('try'), cpsTry);

  cpsCatch = function(ast, contAST, cbAST) {
    var body;
    body = _cpsOne(ast.body, contAST, cbAST);
    return AST["catch"](ast.param, body);
  };

  register(AST.get('catch'), cpsCatch);

  module.exports = {
    register: register,
    get: get,
    override: override,
    transform: cps
  };

}).call(this);
