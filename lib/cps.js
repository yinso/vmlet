// Generated by CoffeeScript 1.4.0
(function() {
  var AST, combine, concat, cps, cpsAssign, cpsBlock, cpsCatch, cpsDefine, cpsIf, cpsLocal, cpsReturn, cpsScalar, cpsTask, cpsTaskcall, cpsThrow, cpsTry, errorlet, get, loglet, makeCallback, makeCpsDef, makeErrorHandler, normalize, override, register, types, util, _cpsOne;

  loglet = require('loglet');

  errorlet = require('errorlet');

  AST = require('./ast');

  util = require('./util');

  types = {};

  register = function(ast, cps) {
    if (types.hasOwnProperty(ast.type)) {
      throw errorlet.create({
        error: 'CPS.duplicate_ast_type',
        type: ast.type
      });
    } else {
      return types[ast.type] = cps;
    }
  };

  get = function(ast) {
    if (types.hasOwnProperty(ast.type())) {
      return types[ast.type()];
    } else {
      throw errorlet.create({
        error: 'CPS.unsupported_as_type',
        type: ast
      });
    }
  };

  override = function(ast, cps) {
    return types[ast.type] = cps;
  };

  /*
  
  CPS occurs with a funcall being async.
  
  res = foo(a, b, c)
  bar...
  baz...
  ==> 
    
  return _rt.tail(foo, a, b, c, function (err, res) {
    if (err) {
      return _rt.tail(cb, err);
    } else {
      bar...
      baz...
    }
    })
  
  The above shows that "bar... baz..." is the continuation of the funcall foo(a, b,, c), and if CPS'd it gets
  translated into the else branch of the callback. Note that res is the result from the function itslef, and 
  we have previously no reference to err symbol (unless we happen to be within a try catch block as well)
  
  Note that we might have to also compile backwards, so we successively generate the intermediate functions.
    
  Also note that we might not necessarily know whether a function is sync/async (we should know if the function is 
    previously created, but we might not know about functions yet to be created, and some functions might be ambiguous)...
  
  In a way - the current design is still ambiguous...
    
  In an if expression, CPS can occur for COND. Since ANF already get the expression separated, it's trivial in this case
  for the CPS.
  
  return _rt.tail(cond, ..., function(err, res) {
    if (err) {
      return _rt.tail(cb, err);
    } else {
      // this part is the original if expression.
      if (res) {
        //... the original then block
      } else {
        // ... the original else block...
      }
    }
  })
  
  Ambiguous can be difficult... but the idea is that we have the if expression (outside of the cond expression) being
  named as a block with the appropriate closure (block will be treated as a function as well).
  
  if a() { b c } else { d e }
  
  a$1 = a()
  block_if = function () {
    if (a$1) {
      b c
    } else {
      d e
    }
  }
  block_if()
  
  it turns out that in order to deal with async in a transparent level - we will need to have the ability to TYPE
  the expression (this is so that we can infer whether or not a particular value will be async).
  
  That means until we can do so, we are stuck with one of the approaches...
  */


  cps = function(anf, contAST, cbAST) {
    var ast;
    if (contAST == null) {
      contAST = AST.symbol('_done');
    }
    if (cbAST == null) {
      cbAST = contAST;
    }
    ast = AST.task(void 0, [AST.param('_rt')], anf);
    return _cpsOne(ast, contAST, cbAST);
  };

  cpsBlock = function(anf, contAST, cbAST) {
    var i, _i, _ref;
    for (i = _i = _ref = anf.items.length - 1; _i >= 0; i = _i += -1) {
      contAST = _cpsOne(anf.items[i], contAST, cbAST);
    }
    return normalize(contAST);
  };

  register(AST.get('block'), cpsBlock);

  _cpsOne = function(item, contAST, cbAST) {
    var cpser;
    cpser = get(item);
    return cpser(item, contAST, cbAST);
  };

  cpsTaskcall = function(ast, contAST, cbAST) {
    var args;
    args = [].concat(ast.args);
    if (contAST.type() === 'procedure') {
      args.push(contAST);
    } else {
      args.push(makeCallback(contAST, cbAST));
    }
    return AST["return"](AST.funcall(ast.funcall, args));
  };

  register(AST.get('taskcall'), cpsTaskcall);

  cpsTask = function(ast, contAST, cbAST) {
    var body, params;
    cbAST = AST.symbol('_done');
    body = normalize(ast.body);
    params = [].concat(ast.params).concat(cbAST);
    return AST.procedure(ast.name, params, _cpsOne(body, cbAST, cbAST));
  };

  register(AST.get('task'), cpsTask);

  combine = function(ast, contAST) {
    if (!contAST) {
      return ast;
    } else if (contAST.type() === 'block') {
      contAST.items.unshift(ast);
      return contAST;
    } else {
      return AST.block([ast, contAST]);
    }
  };

  concat = function(ast1, ast2) {
    var is1anf, is2anf;
    is1anf = ast1.type() === 'block';
    is2anf = ast2.type() === 'block';
    if (is1anf) {
      return AST.block(ast1.items.concat(is2anf ? ast2.items : [ast2]));
    } else {
      return AST.block([ast1].concat(is2anf ? ast2.items : [ast2]));
    }
  };

  normalize = function(ast) {
    if (ast.type() === 'block') {
      return ast;
    } else {
      return AST.block([ast]);
    }
  };

  makeCallback = function(contAST, cbAST, resParam) {
    if (resParam == null) {
      resParam = AST.param('res');
    }
    if (contAST === cbAST) {
      return contAST;
    } else {
      return AST.procedure(void 0, [AST.param('err'), resParam], ASTcond(AST.symbol('err'), AST["return"](AST.funcall(cbAST, [AST.symbol('err')])), contAST));
    }
  };

  cpsLocal = function(ast, contAST, cbAST) {
    var head;
    if (ast.isAsync()) {
      return _cpsOne(ast.value, makeCallback(contAST, cbAST, AST.param(ast.name)), cbAST);
    } else {
      head = AST.local(_cpsOne(ast.value, null, null), ast.init);
      return combine(head, contAST);
    }
  };

  register(AST.get('local'), cpsLocal);

  cpsAssign = function(ast, contAST, cbAST) {
    var head;
    if (ast.isAsync()) {
      return _cpsOne(ast.value, makeCallback(contAST, cbAST, AST.param(ast.name)), cbAST);
    } else {
      head = AST.assign(ast.name, _cpsOne(ast.value, null, null));
      return combine(head, contAST);
    }
  };

  register(AST.get('assign'), cpsAssign);

  makeCpsDef = function(type) {
    return function(ast, contAST, cbAST) {
      var head;
      if (ast.isAsync()) {
        return _cpsOne(ast.value, makeCallback(contAST, cbAST, AST.param(ast.name)), cbAST);
      } else {
        head = AST.make(type, ast.name, _cpsOne(ast.value, null, null));
        return combine(head, contAST);
      }
    };
  };

  cpsDefine = makeCpsDef('define');

  register(AST.get('define'), cpsDefine);

  cpsReturn = function(ast, contAST, cbAST) {
    var val;
    val = ast.value;
    if (val.type() === 'taskcall') {
      return cpsTaskcall(val, contAST, cbAST);
    } else {
      return AST["return"](AST.funcall(cbAST, [AST.make('null'), _cpsOne(val, null, null)]));
    }
  };

  register(AST.get('return'), cpsReturn);

  cpsIf = function(ast, contAST, cbAST) {
    return AST["if"](ast.cond, _cpsOne(ast.then, contAST, cbAST), _cpsOne(ast["else"], contAST, cbAST));
  };

  register(AST.get('if'), cpsIf);

  cpsScalar = function(ast, contAST, cbAST) {
    return combine(ast, contAST);
  };

  register(AST.get('number'), cpsScalar);

  register(AST.get('bool'), cpsScalar);

  register(AST.get('null'), cpsScalar);

  register(AST.get('symbol'), cpsScalar);

  register(AST.get('string'), cpsScalar);

  register(AST.get('binary'), cpsScalar);

  register(AST.get('member'), cpsScalar);

  register(AST.get('procedure'), cpsScalar);

  register(AST.get('proxyval'), cpsScalar);

  register(AST.get('ref'), cpsScalar);

  register(AST.get('funcall'), cpsScalar);

  register(AST.get('array'), cpsScalar);

  register(AST.get('object'), cpsScalar);

  cpsThrow = function(ast, contAST, cbAST) {
    return AST["return"](AST.funcall(cbAST, [ast.value]));
  };

  register(AST.get('throw'), cpsThrow);

  makeErrorHandler = function(catchExp, finallyExp, cbAST, name) {
    var body;
    body = concat(finallyExp.body, catchExp.body);
    body = _cpsOne(body, cbAST, cbAST);
    return AST.local(AST.ref(name, AST.procedure(void 0, [catchExp.param], body)));
  };

  cpsTry = function(ast, contAST, cbAST) {
    var bodyAST, errorAST, name;
    name = '__handleError$1';
    errorAST = makeErrorHandler(ast.catches[0], ast["finally"], cbAST, name);
    cbAST = AST.ref(name);
    bodyAST = _cpsOne(ast.body, contAST, cbAST);
    return combine(errorAST, bodyAST);
  };

  register(AST.get('try'), cpsTry);

  cpsCatch = function(ast, contAST, cbAST) {
    var body;
    body = _cpsOne(ast.body, contAST, cbAST);
    return AST["catch"](ast.param, body);
  };

  register(AST.get('catch'), cpsCatch);

  module.exports = {
    register: register,
    get: get,
    override: override,
    transform: cps
  };

}).call(this);
