// Generated by CoffeeScript 1.4.0
(function() {
  var AST, CodeBlock, Environment, Opcode, ParameterList, Procedure, Ref, baseEnv, compile, compileArray, compileBinary, compileBlock, compileCatch, compileDefine, compileFinally, compileFuncall, compileIdentifier, compileIf, compileMember, compileObject, compileOne, compileParameter, compileParameters, compileProcedure, compileScalar, compileThrow, compileTry, errorlet, get, loglet, override, register, types, _compileCatchClauses;

  loglet = require('loglet');

  CodeBlock = require('./codeblock');

  Ref = require('./ref');

  baseEnv = require('./baseenv');

  Environment = require('../src/environment');

  AST = require('./ast');

  errorlet = require('errorlet');

  Procedure = require('./procedure');

  ParameterList = require('./parameter');

  Opcode = require('./opcode');

  types = {};

  register = function(ast, compiler) {
    if (types.hasOwnProperty(ast.type)) {
      throw errorlet.create({
        error: 'duplicate_ast_type',
        ast: ast
      });
    } else {
      return types[ast.type] = compiler;
    }
  };

  get = function(ast) {
    if (types.hasOwnProperty(ast.type)) {
      return types[ast.type];
    } else {
      throw errorlet.create({
        error: 'unknown_ast_type',
        ast: ast
      });
    }
  };

  override = function(ast, compiler) {
    return types[ast.type] = compiler;
  };

  compile = function(ast, env, code, isTail) {
    if (env == null) {
      env = baseEnv;
    }
    if (code == null) {
      code = new CodeBlock();
    }
    if (isTail == null) {
      isTail = false;
    }
    env = new Environment({}, env);
    if (ast instanceof Array) {
      return compile(ast[0], env, code, isTail);
    } else {
      return compileOne(ast, env, code, isTail);
    }
  };

  compileOne = function(ast, env, code, isTail) {
    var compiler;
    if (code == null) {
      code = new CodeBlock();
    }
    if (isTail == null) {
      isTail = false;
    }
    if (types.hasOwnProperty(ast.constructor.type)) {
      compiler = types[ast.constructor.type];
      return compiler(ast, env, code, isTail);
    } else {
      throw errorlet.create({
        error: 'unsupported_ast_type',
        ast: ast
      });
    }
  };

  compileScalar = function(ast, env, code, isTail) {
    code.push(ast.value);
    return code;
  };

  register(AST.get('bool'), compileScalar);

  register(AST.get('number'), compileScalar);

  register(AST.get('string'), compileScalar);

  register(AST.get('null'), compileScalar);

  compileBlock = function(ast, env, code, isTail) {
    var i, lineAST, _i, _len, _ref;
    _ref = ast.items;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      lineAST = _ref[i];
      if (i === ast.items.length - 1) {
        code.append(compileOne(lineAST, env, new CodeBlock(), isTail));
      } else {
        code.append(compileOne(lineAST, env));
      }
    }
    return code;
  };

  register(AST.get('block'), compileBlock);

  compileIf = function(ast, env, code, isTail) {
    var condCode, elseCode, thenCode;
    condCode = compileOne(astcond, env);
    thenCode = compileOne(ast.then, env, new CodeBlock(), isTail);
    elseCode = compileOne(ast["else"], env, new CodeBlock(), isTail);
    return code.append(condCode).ifOrJump(thenCode.length + 1).append(thenCode).jump(elseCode.length).append(elseCode);
  };

  register(AST.get('if'), compileIf);

  compileFuncall = function(ast, env, code, isTail) {
    var arg, _i, _len, _ref;
    _ref = ast.args;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      arg = _ref[_i];
      code.append(compileOne(arg, env));
    }
    code.append(compileOne(ast.funcall, env));
    if (isTail) {
      return code.tailcall(ast.args.length);
    } else {
      return code.funcall(ast.args.length);
    }
  };

  register(AST.get('funcall'), compileFuncall);

  compileIdentifier = function(ast, env, code, isTail) {
    var object;
    if (!env.has(ast.value)) {
      throw errorlet.create({
        error: 'compileIdentifier:unknown_identifier',
        id: ast.value
      });
    }
    object = env.get(ast.value);
    if (object instanceof Ref) {
      return code.ref(object.name);
    } else {
      return code.push(object);
    }
  };

  register(AST.get('symbol'), compileIdentifier);

  compileDefine = function(ast, env, code, isTail) {
    var valCode;
    if (env.has(ast.name)) {
      throw errorlet.crate({
        error: 'compileDefine:duplicate_definition',
        name: ast.name
      });
    }
    valCode = compile(ast.value, env);
    return code.append(valCode).define(ast.name);
  };

  register(AST.get('define'), compileDefine);

  compileParameter = function(param, env, isTail) {
    var defaultCode;
    defaultCode = param["default"] ? compileOne(param["default"], env) : null;
    env.defineRef(param.name);
    return ParameterList.makeParam(param.name, param.type, defaultCode);
  };

  compileParameters = function(params, env, isTail) {
    var p, paramList;
    paramList = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = params.length; _i < _len; _i++) {
        p = params[_i];
        _results.push(compileParameter(p, env));
      }
      return _results;
    })();
    return ParameterList.make(paramList);
  };

  compileProcedure = function(ast, env, code, isTail) {
    var bodyAST, bodyCode, newEnv, params, proc;
    newEnv = new Environment({}, env);
    params = compileParameters(ast.params, newEnv);
    proc = new Procedure(ast.name, params, null);
    if (proc.name) {
      env.define(proc.name, proc);
    }
    bodyAST = ast.body;
    bodyCode = compileOne(bodyAST, newEnv, new CodeBlock(), true);
    proc.setBody(bodyCode);
    return code.push(proc);
  };

  register(AST.get('procedure'), compileProcedure);

  compileBinary = function(ast, env, code, isTail) {
    var proc;
    if (!env.has(ast.op)) {
      throw {
        error: 'invalid_operator',
        name: ast.op
      };
    }
    proc = env.get(ast.op);
    code.append(compileOne(ast.lhs, env));
    code.append(compileOne(ast.rhs, env));
    switch (ast.op) {
      case '+':
        code.plus();
        break;
      case '-':
        code.minus();
        break;
      case '*':
        code.multiply();
        break;
      case '/':
        code.divide();
        break;
      case '%':
        code.modulo();
        break;
      case '>':
        code.greater();
        break;
      case '>=':
        code.greaterEqual();
        break;
      case '<':
        code.less();
        break;
      case '<=':
        code.lessEqual();
        break;
      case '==':
        code.equal();
        break;
      case '!=':
        code.notEqual();
        break;
      default:
        code.push(proc);
        if (isTail) {
          code.tailcall(2);
        } else {
          code.funcall(2);
        }
    }
    return code;
  };

  register(AST.get('binary'), compileBinary);

  compileCatch = function(ast, env, code, isTail) {
    var body, newEnv, param;
    newEnv = new Environment({}, env);
    param = compileParameter(ast.param, newEnv);
    body = compileOne(ast.body, newEnv);
    return code.ifErrorOrJump(body.length + 4).pushEnv().push(param).bindErrorOrJump(body.length).append(body).popEnv();
  };

  _compileCatchClauses = function(catches, env) {
    var ast, body, clause, clauses, helper, _i, _len;
    helper = function(ast) {
      var body, newEnv, param;
      newEnv = new Environment({}, env);
      param = compileParameter(ast.param, env);
      body = compileOne(ast.body, newEnv);
      return new CodeBlock().push(param).bindErrorOrJump(body.length).append(body);
    };
    clauses = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = catches.length; _i < _len; _i++) {
        ast = catches[_i];
        _results.push(helper(ast));
      }
      return _results;
    })();
    body = new CodeBlock();
    for (_i = 0, _len = clauses.length; _i < _len; _i++) {
      clause = clauses[_i];
      body.append(clause);
    }
    return new CodeBlock().ifErrorOrJump(body.length + 2).pushEnv().append(body).popEnv();
  };

  register(AST.get('catch'), compileCatch);

  compileThrow = function(ast, env, code, isTail) {
    var body;
    body = compileOne(ast.value, env);
    return code.append(body)["throw"]();
  };

  register(AST.get('throw'), compileThrow);

  compileFinally = function(ast, env, code, isTail) {
    var body;
    body = compileOne(ast.body, env);
    return code["finally"]().append(body).endFinally();
  };

  register(AST.get('finally'), compileFinally);

  compileTry = function(ast, env, code, isTail) {
    var body, catchBody, catchLabel, finallyBody, finallyLabel;
    body = compileOne(ast.body, env);
    catchLabel = Opcode.make('label', 'catch');
    finallyLabel = Opcode.make('label', 'finally');
    catchBody = _compileCatchClauses(ast["catch"], env, code);
    finallyBody = ast["finally"] ? compileOne(ast["finally"], env) : new CodeBlock()["finally"]().endFinally();
    return code.onThrowGoto(catchLabel).append(body).label(catchLabel).onThrowGoto(finallyLabel).append(catchBody).label(finallyLabel).append(finallyBody);
  };

  register(AST.get('try'), compileTry);

  compileObject = function(ast, env, code, isTail) {
    var helper, key, valAST, _i, _len, _ref, _ref1;
    helper = function(valAST) {
      return compile(valAST, env);
    };
    _ref = ast.value;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], key = _ref1[0], valAST = _ref1[1];
      code.push(key).append(helper(valAST));
    }
    return code.object(ast.value.length * 2);
  };

  register(AST.get('object'), compileObject);

  compileArray = function(ast, env, code, isTail) {
    var itemAST, _i, _len, _ref;
    _ref = ast.value;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      itemAST = _ref[_i];
      code.append(compile(itemAST, env));
    }
    return code.array(ast.value.length);
  };

  register(AST.get('array'), compileArray);

  compileMember = function(ast, env, code, isTail) {
    var key;
    key = ast.key.value;
    return code.append(compileOne(ast.head, env)).member(key);
  };

  register(AST.get('member'), compileMember);

  module.exports = {
    compile: compile,
    register: register,
    get: get,
    override: override
  };

}).call(this);
