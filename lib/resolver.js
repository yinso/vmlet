// Generated by CoffeeScript 1.4.0
(function() {
  var AST, Environment, FreeVariable, Resolver, TR;

  AST = require('./ast');

  Environment = require('./environment');

  TR = require('./trace');

  FreeVariable = require('./freevariable');

  Resolver = (function() {

    function Resolver() {}

    Resolver.transform = function(ast, env) {
      if (env == null) {
        env = new Environment();
      }
      if (!this.reg) {
        this.reg = new this();
      }
      return this.reg.transform(ast, env);
    };

    Resolver.prototype.transform = function(ast, env) {
      var resolved;
      if (env == null) {
        env = new Environment();
      }
      switch (ast.type()) {
        case 'toplevel':
        case 'module':
          resolved = this.run(ast.body, env);
          return ast.clone(resolved);
        default:
          return this.run(ast, env);
      }
    };

    Resolver.prototype.run = function(ast, env) {
      var type;
      type = "_" + (ast.type());
      if (this[type]) {
        return this[type](ast, env);
      } else {
        throw new Error("Resolver.unknown_ast: " + (ast.type()));
      }
    };

    Resolver.prototype._number = function(ast, env) {
      return ast;
    };

    Resolver.prototype._string = function(ast, env) {
      return ast;
    };

    Resolver.prototype._bool = function(ast, env) {
      return ast;
    };

    Resolver.prototype._null = function(ast, env) {
      return ast;
    };

    Resolver.prototype._unit = function(ast, env) {
      return ast;
    };

    Resolver.prototype._ref = function(ast, env) {
      return ast;
    };

    Resolver.prototype._binary = function(ast, env) {
      var lhs, rhs;
      lhs = this.run(ast.lhs, env);
      rhs = this.run(ast.rhs, env);
      return AST.binary(ast.op, lhs, rhs);
    };

    Resolver.prototype._if = function(ast, env) {
      var cond, elseAST, thenAST;
      cond = this.run(ast.cond, env);
      thenAST = this.run(ast.then, env);
      elseAST = this.run(ast["else"], env);
      return AST["if"](cond, thenAST, elseAST);
    };

    Resolver.prototype._block = function(ast, env) {
      var i, item, items, _i, _len, _ref;
      _ref = ast.items;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        item = _ref[i];
        if (item.type() === 'define') {
          this.defineName(item, env);
        }
      }
      items = (function() {
        var _j, _len1, _ref1, _results;
        _ref1 = ast.items;
        _results = [];
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          item = _ref1[i];
          if (item.type() === 'define') {
            _results.push(this.defineVal(item, env));
          } else {
            _results.push(this.run(item, env));
          }
        }
        return _results;
      }).call(this);
      return AST.block(items);
    };

    Resolver.prototype._toplevel = function(ast, env) {
      return AST.toplevel(this.run(ast.body, env));
    };

    Resolver.prototype.defineName = function(ast, env) {
      var ref;
      if (env.hasCurrent(ast.name)) {
        throw new Error("duplicate_define: " + ast.name);
      }
      ref = env.define(ast.name);
      if (env.level() <= 1) {
        return ref.isDefine = true;
      }
    };

    Resolver.prototype.defineVal = function(ast, env) {
      var ref, res;
      ref = env.get(ast.name);
      res = this.run(ast.value, env);
      ref.value = res;
      return ref.define();
    };

    Resolver.prototype._define = function(ast, env) {
      this.defineName(ast, env);
      return this.defineVal(ast, env);
    };

    Resolver.prototype.assign = function(ast, env) {
      var ref, val;
      ref = this.run(ast.name, env);
      val = this.run(ast.value, env);
      return AST.assign(ref, val);
    };

    Resolver.prototype._symbol = function(ast, env) {
      if (env.hasName(ast)) {
        return env.get(ast);
      } else {
        throw new Error("Resolver.unknown_identifier: " + ast);
      }
    };

    Resolver.prototype._object = function(ast, env) {
      var key, keyVals, v, val;
      keyVals = (function() {
        var _i, _len, _ref, _ref1, _results;
        _ref = ast.value;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], key = _ref1[0], val = _ref1[1];
          v = this.run(val, env);
          _results.push([key, v]);
        }
        return _results;
      }).call(this);
      return AST.object(keyVals);
    };

    Resolver.prototype._array = function(ast, env) {
      var items, v;
      items = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.value;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          _results.push(this.run(v, env));
        }
        return _results;
      }).call(this);
      return AST.array(items);
    };

    Resolver.prototype._member = function(ast, env) {
      var head;
      head = this.run(ast.head, env);
      return AST.member(head, ast.key);
    };

    Resolver.makeProcCall = function(type) {
      return function(ast, env) {
        var arg, args, funcall;
        args = (function() {
          var _i, _len, _ref, _results;
          _ref = ast.args;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            arg = _ref[_i];
            _results.push(this.run(arg, env));
          }
          return _results;
        }).call(this);
        funcall = this.run(ast.funcall, env);
        return AST.make(type, funcall, args);
      };
    };

    Resolver.prototype._funcall = Resolver.makeProcCall('funcall');

    Resolver.prototype._taskcall = Resolver.makeProcCall('taskcall');

    Resolver.prototype._param = function(ast, env) {
      var ref;
      ref = env.define(ast.name, ast);
      ast.name = ref;
      return ast;
    };

    Resolver.makeProc = function(type) {
      return function(ast, env) {
        var decl, newEnv, param, params, ref;
        newEnv = new Environment(env);
        params = (function() {
          var _i, _len, _ref, _results;
          _ref = ast.params;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            param = _ref[_i];
            _results.push(this.run(param, newEnv));
          }
          return _results;
        }).call(this);
        decl = AST.make(type, ast.name, params, null);
        if (ast.name) {
          if (env.has(ast.name) && env.get(ast.name).isPlaceholder()) {
            ref = env.get(ast.name);
            ref.value = decl;
            decl.name = ref;
          } else {
            ref = newEnv.define(ast.name, decl);
            decl.name = ref;
          }
        }
        decl.body = this.run(ast.body, newEnv);
        decl.frees = FreeVariable.transform(decl, newEnv);
        return decl;
      };
    };

    Resolver.prototype._procedure = Resolver.makeProc('procedure');

    Resolver.prototype._task = Resolver.makeProc('task');

    Resolver.prototype._throw = function(ast, env) {
      var exp;
      exp = this.run(ast.value, env);
      return AST["throw"](exp);
    };

    Resolver.prototype._catch = function(ast, env) {
      var body, newEnv, ref;
      newEnv = new Environment(env);
      ref = newEnv.defineParam(ast.param);
      body = this.run(ast.body, newEnv);
      return AST["catch"](ast.param, body);
    };

    Resolver.prototype._finally = function(ast, env) {
      var body;
      body = _transform(ast.body, env);
      return AST["finally"](body);
    };

    Resolver.prototype._try = function(ast, env) {
      var body, c, catches, fin, newEnv;
      newEnv = new Environment(env);
      body = this.run(ast.body, newEnv);
      catches = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.catches;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          _results.push(this._catch(c, env));
        }
        return _results;
      }).call(this);
      fin = ast["finally"] instanceof AST ? this._finally(ast["finally"], env) : null;
      return AST["try"](body, catches, fin);
    };

    Resolver.prototype._import = function(ast, env) {
      var binding, res, _i, _len, _ref;
      _ref = ast.bindings;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        binding = _ref[_i];
        res = env.define(binding.as, ast.proxy(binding));
      }
      return ast;
    };

    Resolver.prototype._export = function(ast, env) {
      var binding, bindings;
      bindings = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.bindings;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          binding = _ref[_i];
          if (!env.has(binding.spec)) {
            throw new Error("export:unknown_identifier: " + binding.binding);
          } else {
            _results.push(AST.binding(env.get(binding.spec), binding.as));
          }
        }
        return _results;
      })();
      return AST["export"](bindings);
    };

    Resolver.prototype._let = function(ast, env) {
      var body, define, defines, newEnv;
      newEnv = new Environment(env);
      defines = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.defines;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          define = _ref[_i];
          _results.push(this.run(define, newEnv));
        }
        return _results;
      }).call(this);
      body = this.run(ast.body, newEnv);
      return AST["let"](defines, body);
    };

    Resolver.prototype._while = function(ast, env) {
      var block, cond;
      cond = this.run(ast.cond, env);
      block = this.run(at.blcok, env);
      return AST["while"](cond, block);
    };

    Resolver.prototype._return = function(ast, env) {
      return AST["return"](this.run(ast.value, env));
    };

    Resolver.prototype._continue = function(ast, env) {
      return ast;
    };

    Resolver.prototype._break = function(ast, env) {
      return ast;
    };

    return Resolver;

  })();

  module.exports = Resolver;

}).call(this);
