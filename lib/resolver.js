// Generated by CoffeeScript 1.4.0
(function() {
  var AST, SymbolTable, errorlet, get, loglet, makeProc, register, tr, transform, util, _array, _binary, _block, _catch, _define, _defineName, _defineVal, _export, _finally, _funcall, _identifier, _if, _import, _let, _member, _object, _param, _scalar, _taskcall, _throw, _toplevel, _transform, _try, _types;

  loglet = require('loglet');

  errorlet = require('errorlet');

  AST = require('./ast');

  SymbolTable = require('./environment');

  tr = require('./trace');

  util = require('./util');

  _types = {};

  register = function(ast, transformer) {
    if (_types.hasOwnProperty(ast.type)) {
      throw errorlet.create({
        error: 'resolver_duplicate_ast_type',
        type: ast.type
      });
    } else {
      return _types[ast.type] = transformer;
    }
  };

  get = function(ast) {
    if (_types.hasOwnProperty(ast.constructor.type)) {
      return _types[ast.constructor.type];
    } else {
      throw errorlet.create({
        error: 'resolver_unsupported_ast_type',
        type: ast.constructor.type
      });
    }
  };

  transform = function(ast, env) {
    var resolved;
    switch (ast.type()) {
      case 'toplevel':
      case 'module':
        resolved = _transform(ast.body, env);
        return ast.clone(resolved);
      default:
        return _transform(ast, env);
    }
  };

  _transform = function(ast, env) {
    var resolver;
    resolver = get(ast);
    return resolver(ast, env);
  };

  _scalar = function(ast, env) {
    return ast;
  };

  register(AST.get('number'), _scalar);

  register(AST.get('bool'), _scalar);

  register(AST.get('null'), _scalar);

  register(AST.get('string'), _scalar);

  register(AST.get('ref'), _scalar);

  register(AST.get('unit'), _scalar);

  _binary = function(ast, env) {
    var lhs, rhs;
    lhs = _transform(ast.lhs, env);
    rhs = _transform(ast.rhs, env);
    return AST.binary(ast.op, lhs, rhs);
  };

  register(AST.get('binary'), _binary);

  _if = function(ast, env) {
    var cond, elseAST, thenAST;
    cond = _transform(ast.cond, env);
    thenAST = _transform(ast.then, env);
    elseAST = _transform(ast["else"], env);
    return AST["if"](cond, thenAST, elseAST);
  };

  register(AST.get('if'), _if);

  _block = function(ast, env) {
    var i, item, items, _i, _len, _ref;
    _ref = ast.items;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      item = _ref[i];
      if (item.type() === 'define') {
        _defineName(item, env);
      }
    }
    items = (function() {
      var _j, _len1, _ref1, _results;
      _ref1 = ast.items;
      _results = [];
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        item = _ref1[i];
        if (item.type() === 'define') {
          _results.push(_defineVal(item, env));
        } else {
          _results.push(_transform(item, env));
        }
      }
      return _results;
    })();
    return AST.block(items);
  };

  register(AST.get('block'), _block);

  _toplevel = function(ast, env) {
    return AST.toplevel(_transform(ast.body, env));
  };

  register(AST.get('toplevel'), _toplevel);

  _defineName = function(ast, env) {
    var ref;
    if (env.hasCurrent(ast.name)) {
      throw new Error("duplicate_define: " + ast.name);
    }
    ref = env.define(ast.name);
    if (env.level() <= 1) {
      return ref.isDefine = true;
    }
  };

  _defineVal = function(ast, env) {
    var ref, res;
    ref = env.get(ast.name);
    res = _transform(ast.value, env);
    ref.value = res;
    return ref.define();
  };

  _define = tr.trace('resolver.define', function(ast, env) {
    _defineName(ast, env);
    return _defineVal(ast, env);
  });

  register(AST.get('define'), _define);

  _identifier = function(ast, env) {
    if (env.hasName(ast)) {
      return env.get(ast);
    } else {
      throw errorlet.create({
        error: 'RESOLVER.transform:unknown_identifier',
        id: ast
      });
    }
  };

  register(AST.get('symbol'), _identifier);

  _object = function(ast, env) {
    var key, keyVals, v, val;
    keyVals = (function() {
      var _i, _len, _ref, _ref1, _results;
      _ref = ast.value;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], key = _ref1[0], val = _ref1[1];
        v = _transform(val, env);
        _results.push([key, v]);
      }
      return _results;
    })();
    return AST.object(keyVals);
  };

  register(AST.get('object'), _object);

  _array = function(ast, env) {
    var items, v;
    items = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.value;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(_transform(v, env));
      }
      return _results;
    })();
    return AST.array(items);
  };

  register(AST.get('array'), _array);

  _member = function(ast, env) {
    var head;
    head = _transform(ast.head, env);
    return AST.member(head, ast.key);
  };

  register(AST.get('member'), _member);

  _funcall = function(ast, env) {
    var arg, args, funcall;
    args = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.args;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        _results.push(_transform(arg, env));
      }
      return _results;
    })();
    funcall = _transform(ast.funcall, env);
    return AST.make('funcall', funcall, args);
  };

  register(AST.get('funcall'), _funcall);

  _taskcall = function(ast, env) {
    var arg, args, funcall;
    args = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.args;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        _results.push(_transform(arg, env));
      }
      return _results;
    })();
    funcall = _transform(ast.funcall, env);
    return AST.make('taskcall', funcall, args);
  };

  register(AST.get('taskcall'), _taskcall);

  _param = function(ast, env) {
    return ast;
  };

  register(AST.get('param'), _param);

  makeProc = function(type) {
    return function(ast, env) {
      var decl, newEnv, param, params;
      newEnv = new SymbolTable(env);
      params = (function() {
        var _i, _len, _ref, _results;
        _ref = ast.params;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          param = _ref[_i];
          _results.push(newEnv.defineParam(param));
        }
        return _results;
      })();
      decl = AST.make(type, ast.name, params, null);
      if (ast.name) {
        if (env.has(ast.name) && env.get(ast.name).isPlaceholder()) {
          env.get(ast.name).value = decl;
        } else {
          newEnv.define(ast.name, decl);
        }
      }
      decl.body = _transform(ast.body, newEnv);
      return decl;
    };
  };

  register(AST.get('procedure'), makeProc('procedure'));

  register(AST.get('task'), makeProc('task'));

  _throw = function(ast, env) {
    var exp;
    exp = _transform(ast.value, env);
    return AST.make('throw', exp);
  };

  register(AST.get('throw'), _throw);

  _catch = function(ast, env) {
    var body, newEnv, ref;
    newEnv = new SymbolTable(env);
    ref = newEnv.defineParam(ast.param);
    body = _transform(ast.body, newEnv);
    return AST.make('catch', ast.param, body);
  };

  _finally = function(ast, env) {
    var body, newEnv;
    newEnv = new SymbolTable(env);
    body = _transform(ast.body, newEnv);
    return AST.make('finally', body);
  };

  _try = function(ast, env) {
    var body, c, catches, fin, newEnv;
    newEnv = new SymbolTable(env);
    body = _transform(ast.body, newEnv);
    catches = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.catches;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(_catch(c, env));
      }
      return _results;
    })();
    fin = ast["finally"] instanceof AST ? _finally(ast["finally"], env) : null;
    return AST.make('try', body, catches, fin);
  };

  register(AST.get('try'), _try);

  _import = function(ast, env) {
    var binding, _i, _len, _ref;
    _ref = ast.bindings;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      binding = _ref[_i];
      env.define(binding.as, ast.proxy(binding));
    }
    return ast;
  };

  register(AST.get('import'), _import);

  _export = function(ast, env) {
    var binding, bindings;
    bindings = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.bindings;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        binding = _ref[_i];
        if (!env.has(binding.spec)) {
          throw new Error("export:unknown_identifier: " + binding.binding);
        } else {
          _results.push(AST.binding(env.get(binding.spec), binding.as));
        }
      }
      return _results;
    })();
    return AST["export"](bindings);
  };

  register(AST.get('export'), _export);

  _let = function(ast, env) {
    var body, define, defines, newEnv;
    newEnv = new SymbolTable(env);
    defines = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.defines;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        define = _ref[_i];
        _results.push(_transform(define, newEnv));
      }
      return _results;
    })();
    body = _transform(ast.body, newEnv);
    return AST["let"](defines, body);
  };

  register(AST.get('let'), _let);

  module.exports = {
    transform: transform,
    register: register,
    get: get
  };

}).call(this);
