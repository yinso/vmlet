// Generated by CoffeeScript 1.4.0
(function() {
  var AST, Environment, REF, TR, determineRefLocation, isTailCall, isTailRecursive, normalize, normalizeRefs, tailRecursive, transform, _goto;

  AST = require('./ast');

  Environment = require('./environment');

  TR = require('./trace');

  REF = require('./ref');

  transform = function(ast) {
    var ref, refs, res, trans, _i, _len;
    res = isTailRecursive(ast.body, ast);
    refs = REF.transform(ast);
    for (_i = 0, _len = refs.length; _i < _len; _i++) {
      ref = refs[_i];
      if (ref.value.type() === 'procedure') {
        console.log('-- TCO.transform.ref.proc', ast.name, ref, ast.name === ref, ref.value);
      } else if (ref.value.type() === 'proxyval') {
        console.log('-- TCO.transform.ref.proxval', ast.name, ref);
      }
    }
    if (res) {
      trans = tailRecursive(ast);
      return trans;
    } else {
      return ast;
    }
  };

  tailRecursive = function(proc) {
    var body, labelDef, labelName, labelVar, whileBlock;
    labelVar = AST.symbol('label');
    labelName = proc.name.literal();
    labelDef = AST.local(labelVar, labelName);
    body = normalize(proc.body, proc, labelVar);
    whileBlock = AST["while"](AST.bool(true), AST.block([AST["switch"](labelVar, [AST["case"](labelName, body)])]));
    proc.body = AST.block([labelDef, whileBlock]);
    return proc;
  };

  normalize = function(ast, proc, labelVar) {
    var elseAST, funcall, i, item, items, thenAST, value;
    switch (ast.type()) {
      case 'block':
        items = (function() {
          var _i, _len, _ref, _results;
          _ref = ast.items;
          _results = [];
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            item = _ref[i];
            if (i < ast.items.length - 1) {
              _results.push(item);
            } else {
              _results.push(normalize(item, proc, labelVar));
            }
          }
          return _results;
        })();
        return AST.block(items);
      case 'return':
        value = normalize(ast.value, proc, labelVar);
        if (value.type() === 'block') {
          return value;
        } else {
          return AST["return"](value);
        }
        break;
      case 'if':
        thenAST = normalize(ast.then, proc, labelVar);
        elseAST = normalize(ast["else"], proc, labelVar);
        return AST["if"](ast.cond, thenAST, elseAST);
      case 'funcall':
        funcall = ast.funcall;
        switch (funcall.type()) {
          case 'ref':
            if (funcall.value === proc) {
              return _goto(ast, proc, labelVar);
            } else {
              return ast;
            }
            break;
          default:
            return ast;
        }
        break;
      default:
        return ast;
    }
  };

  _goto = function(ast, proc, labelVar) {
    var arg, i, items, labelName, param, tempVars, _i, _j, _len, _len1, _ref, _ref1;
    labelName = proc.name.literal();
    items = [];
    tempVars = (function() {
      var _i, _len, _ref, _results;
      _ref = proc.params;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        param = _ref[i];
        _results.push(param.name.clone());
      }
      return _results;
    })();
    _ref = ast.args;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      arg = _ref[i];
      items.push(AST.local(tempVars[i], arg));
    }
    _ref1 = ast.args;
    for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
      arg = _ref1[i];
      items.push(AST.assign(proc.params[i].ref(), tempVars[i]));
    }
    items.push(AST.assign(labelVar, labelName));
    items.push(AST["break"]());
    return AST.block(items);
  };

  isTailRecursive = function(ast, proc) {
    var funcall;
    switch (ast.type()) {
      case 'block':
        if (ast.items.length === 0) {
          return false;
        } else {
          return isTailRecursive(ast.items[ast.items.length - 1], proc);
        }
        break;
      case 'if':
        return isTailRecursive(ast.then, proc) || isTailRecursive(ast["else"], proc);
      case 'return':
        return isTailRecursive(ast.value, proc);
      case 'funcall':
        funcall = ast.funcall;
        switch (funcall.type()) {
          case 'ref':
            return funcall.value === proc;
          case 'symbol':
            return funcall === proc.name;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
  };

  isTailCall = function(ast, proc) {
    var funcall;
    switch (ast.type()) {
      case 'procedure':
        return isTailCall(ast.body);
      case 'block':
        return isTailCall(ast.items[ast.items.length - 1]);
      case 'return':
        return isTailCall(ast.value);
      case 'funcall':
        funcall = ast.funcall;
        return true;
      case 'if':
        return isTailCall(ast.then) || isTailCall(ast["else"]);
      default:
        return false;
    }
  };

  determineRefLocation = function(ast) {};

  normalizeRefs = function(ast) {};

  module.exports = {
    transform: transform
  };

}).call(this);
