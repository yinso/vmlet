// Generated by CoffeeScript 1.4.0
(function() {
  var AST, CodeBlock, Environment, Frame, Procedure, Promise, Task, baseEnv, compileProcedure, compiler, errorlet, loglet, makeProcedure, oldCompileProc,
    __slice = [].slice;

  loglet = require('loglet');

  Promise = require('./promise');

  Frame = require('./frame');

  Environment = require('./environment');

  errorlet = require('errorlet');

  CodeBlock = require('./codeblock');

  Procedure = require('./procedure');

  baseEnv = require('./baseenv');

  Task = (function() {

    function Task(codeBlock, env) {
      this.codeBlock = codeBlock;
      this.env = env != null ? env : new Environment();
      this.pushFrame(this.codeBlock);
      this.running = true;
    }

    Task.prototype.isRunning = function() {
      return this.running;
    };

    Task.prototype.suspend = function() {
      return this.running = false;
    };

    Task.prototype.resume = function() {
      this.running = true;
      return this.runLoop();
    };

    Task.prototype.pushFrame = function(code) {
      return this.top = new Frame(code, this.top, this);
    };

    Task.prototype.popFrame = function(val) {
      if (this.top.prev) {
        this.top = this.top.prev;
        this.top.push(val);
        if (this.hasError()) {
          return this.top["throw"](this.error);
        }
      } else {
        return this.top["throw"](errorlet.create({
          error: 'Task.popFrame:call_stack_underflow'
        }));
      }
    };

    Task.prototype.runLoop = function() {
      var opcode;
      while (this.isRunning() && (opcode = this.top.current())) {
        try {
          opcode.run(this.top);
        } catch (e) {
          this.top["throw"](e);
        }
      }
      if (this.isRunning()) {
        try {
          return this.resolve(this.top.pop());
        } catch (e) {
          return this.top["throw"](e);
        }
      }
    };

    Task.prototype.run = function(cb) {
      this.cb = cb;
      this.setupPromise(this.cb);
      return this.runLoop();
    };

    Task.prototype.setupPromise = function(cb) {
      this.deferred = Promise.defer();
      return this.deferred.promise.then(function(v) {
        return cb(null, v);
      })["catch"](function(e) {
        return cb(e);
      });
    };

    Task.prototype.setError = function(e) {
      return this.error = e;
    };

    Task.prototype.hasError = function() {
      return this.hasOwnProperty('error');
    };

    Task.prototype.popError = function() {
      var e;
      e = this.error;
      delete this.error;
      return e;
    };

    Task.prototype.resolve = function(v) {
      if (this.running) {
        this.running = false;
        return this.deferred.resolve(v);
      }
    };

    Task.prototype.reject = function(e) {
      if (this.running) {
        this.running = false;
        return this.deferred.reject(e);
      }
    };

    return Task;

  })();

  AST = require('./ast');

  compiler = require('./compiler');

  oldCompileProc = compiler.get(AST.get('proc'));

  compileProcedure = function(ast, env, code, isTail) {
    var proc, res;
    loglet.log('compileProcedure.called');
    res = oldCompileProc(ast, env, new CodeBlock(), isTail);
    proc = makeProcedure(res.items[0].push);
    return code.push(proc);
  };

  makeProcedure = function(proc) {
    var outer;
    outer = function() {
      var arg, args, cb, code, task, _i, _j, _len;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), cb = arguments[_i++];
      if (!(typeof cb === 'function' || cb instanceof Function)) {
        args.push(cb);
        cb = function(err, res) {
          if (err) {
            return loglet.error(err);
          } else {
            return loglet.log(res);
          }
        };
      }
      code = new CodeBlock();
      for (_j = 0, _len = args.length; _j < _len; _j++) {
        arg = args[_j];
        code.push(arg);
      }
      code.push(proc).funcall(args.length);
      task = new Task(code);
      return task.run(cb);
    };
    outer.__vmlet = {
      procedure: proc
    };
    return outer;
  };

  module.exports = Task;

}).call(this);
