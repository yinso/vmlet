// Generated by CoffeeScript 1.4.0
(function() {
  var EventEmitter, Repl, extend, filter, fs, readline,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  readline = require('readline');

  EventEmitter = require('events').EventEmitter;

  fs = require('fs');

  extend = function() {
    var key, obj, objects, result, val, _i, _len;
    objects = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    result = {};
    for (_i = 0, _len = objects.length; _i < _len; _i++) {
      obj = objects[_i];
      for (key in obj) {
        val = obj[key];
        if (obj.hasOwnProperty(key)) {
          result[key] = val;
        }
      }
    }
    return result;
  };

  filter = function(ary, pred) {
    var item, result, _i, _len;
    result = [];
    for (_i = 0, _len = ary.length; _i < _len; _i++) {
      item = ary[_i];
      if (pred(item)) {
        result.push(item);
      }
    }
    return result;
  };

  Repl = (function(_super) {

    __extends(Repl, _super);

    Repl.start = function(options) {
      var defaultOptions;
      if (options == null) {
        options = {};
      }
      defaultOptions = {
        input: process.stdin,
        output: process.stdout,
        error: process.stderr,
        prompt: '$>',
        onEval: function(repl, cmd, cb) {
          if (cmd === 'undefined') {
            return cb(null, void 0);
          } else if (cmd === 'error') {
            return cb(new Error("this_is_an_error_object"));
          } else {
            return cb(null, cmd);
          }
        },
        historyFile: '.history.log',
        historySize: 30,
        onError: function(repl, err) {
          repl.errorWriteLine('<ERROR>');
          if (err.fileName) {
            repl.errorWriteLine("-- on " + err.fileName + ", " + err.lineNumber);
          }
          return repl.errorWriteLine(err.stack);
        },
        onResult: function(repl, res) {
          return repl.writeLine("" + res);
        },
        onParse: function(repl, text) {
          return {
            state: 'ok',
            parsed: text
          };
        },
        onTabCompletion: function(repl, text) {
          return [["" + text + "_tabbed"], text];
        }
      };
      return new Repl(extend({}, defaultOptions, options));
    };

    Repl.prototype.loadHistory = function() {
      var historySize, repl;
      historySize = this.options.historySize || 30;
      repl = this;
      this.readline._addHistory = function() {
        if (this.line.length === 0) {
          return '';
        }
        if (this.history.length === 0 || this.history[0] !== this.line) {
          this.history.unshift(this.line);
          if (this.history.length > historySize) {
            this.history.pop();
          }
        }
        this.historyIndex = -1;
        return this.history[0];
      };
      try {
        this.readline.history = fs.readFileSync(this.options.historyFile, 'utf8').split('\n').reverse();
        return this.readline.historyIndex = -1;
      } catch (e) {
        return [];
      }
    };

    Repl.prototype.saveHistory = function() {
      var history,
        _this = this;
      history = filter(this.readline.history.reverse(), function(line) {
        return !_this.commands.hasOwnProperty(line);
      });
      return fs.writeFileSync(this.options.historyFile, history.join('\n'), 'utf8');
    };

    function Repl(options) {
      var i,
        _this = this;
      this.options = options;
      this.onTabCompletion = __bind(this.onTabCompletion, this);

      this.onExit = __bind(this.onExit, this);

      this.displayPrompt = __bind(this.displayPrompt, this);

      this.onInterrupt = __bind(this.onInterrupt, this);

      this.handleResult = __bind(this.handleResult, this);

      this.onLine = __bind(this.onLine, this);

      this.readline = readline.createInterface({
        input: this.options.input,
        output: this.options.output,
        completer: this.onTabCompletion,
        terminal: true
      });
      this.commands = [];
      this.continuingPrompt = ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.options.prompt.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(' ');
        }
        return _results;
      }).call(this)).join('');
      this.readline.on('close', this.onExit);
      this.readline.on('SIGINT', this.onInterrupt);
      this.readline.on('SIGCONT', this.displayPrompt);
      this.readline.on('line', this.onLine);
      this.loadHistory();
      this.commands['.history'] = {
        help: 'Show the history',
        action: function(repl) {
          var h, out;
          out = (function() {
            var _i, _len, _ref, _results;
            _ref = this.readline.history;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              h = _ref[_i];
              _results.push(h);
            }
            return _results;
          }).call(_this);
          return repl.writeLine(out.reverse().join('\n'));
        }
      };
      this.commands['.quit'] = {
        help: 'Quit the program',
        action: function(repl) {
          return repl.readline.close();
        }
      };
      this.beenInterrupted = false;
      this.buffer = '';
      this.displayPrompt();
    }

    Repl.prototype.onLine = function(cmd) {
      var fullCommand, parsed, state, _ref;
      this.beenInterrupted = false;
      fullCommand = this.buffer + cmd + '\n';
      if (this.commands.hasOwnProperty(cmd)) {
        this.commands[cmd].action(this);
        return this.displayPrompt();
      } else {
        try {
          _ref = this.options.onParse(this, fullCommand), state = _ref.state, parsed = _ref.parsed;
          if (state === 'ok') {
            this.buffer = '';
            return this.options.onEval(this, fullCommand, parsed, this.handleResult);
          } else if (state === 'more') {
            this.buffer = fullCommand;
            return this.displayPrompt();
          } else if (state === 'error') {
            this.buffer = '';
            this.options.onError(this, parsed);
            return this.displayPrompt();
          } else {
            throw new Error("unknown_parse_state: " + fullCommand + " ==> " + state + ", " + parsed);
          }
        } catch (e) {
          this.options.onError(this, e);
          return this.displayPrompt();
        }
      }
    };

    Repl.prototype.writeLine = function(text) {
      return this.readline.output.write("" + text + "\n");
    };

    Repl.prototype.write = function(text) {
      return this.readline.output.write(text);
    };

    Repl.prototype.errorWrite = function(text) {
      return this.options.error.write("!!! " + text);
    };

    Repl.prototype.errorWriteLine = function(text) {
      return this.options.error.write("!!! " + text + "\n");
    };

    Repl.prototype.handleResult = function(err, res) {
      try {
        if (err) {
          this.options.onError(this, err);
        } else {
          this.options.onResult(this, res);
        }
      } catch (e) {
        this.errorWriteLine('<REPL_ERROR>');
        this.errorWriteLine("" + err);
      }
      return this.displayPrompt();
    };

    Repl.prototype.onInterrupt = function() {
      this.readline.clearLine();
      if (this.beenInterrupted) {
        this.beenInterrupted = false;
        return this.readline.close();
      } else {
        this.beenInterrupted = true;
        this.readline.output.write('(^C again to quit)\n');
        return this.displayPrompt();
      }
    };

    Repl.prototype.displayPrompt = function(preserveCursor) {
      var prompt;
      if (preserveCursor == null) {
        preserveCursor = true;
      }
      prompt = this.buffer.length > 0 ? this.continuingPrompt + ' ' : this.options.prompt + ' ';
      this.readline.setPrompt(prompt);
      return this.readline.prompt(preserveCursor);
    };

    Repl.prototype.onExit = function() {
      this.emit('exit');
      this.saveHistory();
      return process.exit();
    };

    Repl.prototype.onTabCompletion = function(text) {
      return this.options.onTabCompletion(this, text);
    };

    return Repl;

  })(EventEmitter);

  module.exports = Repl;

}).call(this);
