// Generated by CoffeeScript 1.4.0
(function() {
  var AST, Environment, escodegen, get, register, transArray, transAssign, transBinary, transBlock, transCatch, transDefine, transFinally, transFuncall, transIf, transLocal, transObject, transProcedure, transRef, transReturn, transScalar, transSymbol, transTask, transTry, transform, _types;

  AST = require('./ast');

  escodegen = require('escodegen');

  Environment = (function() {

    function Environment(prev) {
      this.prev = prev != null ? prev : null;
      this.inner = {};
      this.symMap = this.prev ? this.prev.symMap : {};
    }

    Environment.prototype._has = function(sym) {
      return this.inner.hasOwnProperty(sym.value);
    };

    Environment.prototype.has = function(sym) {
      if (this._has(sym)) {
        return true;
      } else if (this.prev) {
        return this.prev.has(sym);
      } else {
        return false;
      }
    };

    Environment.prototype.get = function(sym) {
      if (this._has(sym)) {
        return this.inner[sym.value];
      } else if (this.prev) {
        return this.prev.get(sym);
      } else {
        throw new Error("unknown_identifier: " + sym);
      }
    };

    Environment.prototype.gensym = function(sym) {
      this.symMap[sym.value] = this.symMap.hasOwnProperty(sym.value) ? this.symMap[sym.value] + 1 : 1;
      return AST.symbol("" + sym.value + "$" + this.symMap[sym.value]);
    };

    Environment.prototype.alias = function(sym) {
      var newSym, _ref;
      newSym = ((_ref = this.prev) != null ? _ref.has(sym) : void 0) ? this.gensym(sym) : sym;
      this.inner[sym.value] = newSym;
      return newSym;
    };

    Environment.prototype.defineParam = function(param) {
      var alias;
      alias = this.alias(param.name);
      return AST.param(alias, param.paramType, param["default"]);
    };

    Environment.prototype.define = function(sym, val) {
      var alias;
      alias = this.alias(sym);
      return AST.define(alias, val);
    };

    Environment.prototype.local = function(sym, val) {
      var alias;
      alias = this.alias(sym);
      return AST.local(alias, val);
    };

    return Environment;

  })();

  _types = {};

  register = function(type, trans) {
    if (_types.hasOwnProperty(type.type)) {
      throw new Error("UNIQUE.register:type_exists: " + type.type);
    }
    return _types[type.type] = trans;
  };

  get = function(ast) {
    if (!_types.hasOwnProperty(ast.type())) {
      throw new Error("UNIQUE.register:unknown_type: " + (ast.type()) + ": " + ast);
    }
    return _types[ast.type()];
  };

  transform = function(ast, env) {
    var res, trans;
    if (env == null) {
      env = new Environment();
    }
    trans = get(ast);
    res = trans(ast, env);
    return res;
  };

  transScalar = function(ast, env) {
    return ast;
  };

  register(AST.get('number'), transScalar);

  register(AST.get('string'), transScalar);

  register(AST.get('bool'), transScalar);

  register(AST.get('null'), transScalar);

  register(AST.get('unit'), transScalar);

  transDefine = function(ast, env) {
    var name;
    name = transform(ast.name);
    return AST.define(name, transform(ast.value));
  };

  register(AST.get('define'), transDefine);

  transLocal = function(ast, env) {
    var name;
    name = transform(ast.name);
    return AST.local(name, ast.value ? transform(ast.value) : ast.value);
  };

  register(AST.get('local'), transLocal);

  transAssign = function(ast, env) {
    var name;
    name = transform(ast.name);
    return AST.assign(name, ast.value ? transform(ast.value) : ast.value);
  };

  register(AST.get('assign'), transAssign);

  transSymbol = function(ast, env) {
    if (!env.has(ast)) {
      return env.alias(ast);
    } else {
      return env.get(ast);
    }
  };

  register(AST.get('symbol'), transSymbol);

  transRef = function(ast, env) {
    return transSymbol(ast.name, env);
  };

  register(AST.get('ref'), transRef);

  transBlock = function(ast, env) {
    var item, items, newEnv;
    newEnv = new Environment(env);
    items = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.items;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _results.push(transform(item, newEnv));
      }
      return _results;
    })();
    return AST.block(items);
  };

  register(AST.get('block'), transBlock);

  transArray = function(ast, env) {
    var item, items;
    items = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.value;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _results.push(transform(item, env));
      }
      return _results;
    })();
    return AST.array(items);
  };

  register(AST.get('array'), transArray);

  transObject = function(ast, env) {
    var key, keyvals, val;
    keyvals = (function() {
      var _i, _len, _ref, _ref1, _results;
      _ref = ast.value;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], key = _ref1[0], val = _ref1[1];
        _results.push([key, transform(val, env)]);
      }
      return _results;
    })();
    return AST.object(keyvals);
  };

  register(AST.get('object'), transObject);

  transBinary = function(ast, env) {
    return AST.binary(ast.op, transform(ast.lhs, env), transform(ast.rhs, env));
  };

  register(AST.get('binary'), transBinary);

  transIf = function(ast, env) {
    return AST["if"](transform(ast.cond, env), transform(ast.then, env), transform(ast["else"], env));
  };

  register(AST.get('if'), transIf);

  transTry = function(ast, env) {
    var c, catches, finalAST;
    catches = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.catches;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(transCatch(c, env));
      }
      return _results;
    })();
    finalAST = ast["finally"] ? transFinally(ast["finally"], env) : ast["finally"];
    return AST["try"](transform(ast.body), catches, finalAST);
  };

  register(AST.get('try'), transTry);

  transCatch = function(ast, env) {
    var body, newEnv, param;
    newEnv = new Environment(env);
    param = newEnv.defineParam(ast.param);
    body = transform(ast.body, newEnv);
    return AST["catch"](param, body);
  };

  transFinally = function(ast, env) {
    if (ast) {
      return transform(ast.body, env);
    } else {
      return ast;
    }
  };

  transFuncall = function(ast, env) {
    var arg, args, funcall;
    funcall = transform(ast.funcall, env);
    args = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.args;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        _results.push(transform(arg, env));
      }
      return _results;
    })();
    return AST.funcall(funcall, args);
  };

  register(AST.get('funcall'), transFuncall);

  register(AST.get('taskcall'), transFuncall);

  transReturn = function(ast, env) {
    return AST["return"](transform(ast.value, env));
  };

  register(AST.get('return'), transReturn);

  transProcedure = function(ast, env) {
    var body, name, newEnv, param, params;
    newEnv = new Environment(env);
    params = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.params;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        param = _ref[_i];
        _results.push(newEnv.defineParam(param));
      }
      return _results;
    })();
    name = ast.name ? env.has(ast.name) ? env.get(ast.name) : newEnv.alias(ast.name) : ast.name;
    body = transform(ast.body, newEnv);
    return AST.procedure(ast.name, params, body);
  };

  register(AST.get('procedure'), transProcedure);

  transTask = function(ast, env) {
    var body, name, newEnv, param, params;
    newEnv = new Environment(env);
    params = (function() {
      var _i, _len, _ref, _results;
      _ref = ast.params;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        param = _ref[_i];
        _results.push(newEnv.defineParam(param));
      }
      return _results;
    })();
    name = ast.name ? env.has(ast.name) ? env.get(ast.name) : newEnv.alias(ast.name) : ast.name;
    body = transform(ast.body, newEnv);
    return AST.task(ast.name, params, body);
  };

  register(AST.get('task'), transTask);

  module.exports = {
    register: register,
    transform: transform
  };

}).call(this);
